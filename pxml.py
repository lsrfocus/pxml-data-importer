#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Apr 14 17:07:56 2016 by generateDS.py version 2.22a.
#
# Command line options:
#   ('-o', 'pxml.py')
#   ('-s', 'pxml_subs.py')
#
# Command line arguments:
#   PalantirXMLImportSchema.xsd
#
# Command line:
#   generateDS.py -o "pxml.py" -s "pxml_subs.py" PalantirXMLImportSchema.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.22a0
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser(huge_tree=True)
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class stringPositionLocator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, startPosition=None, endPosition=None, sentenceNumber=None, paragraphNumber=None):
        self.original_tagname_ = None
        self.startPosition = _cast(int, startPosition)
        self.endPosition = _cast(int, endPosition)
        self.sentenceNumber = _cast(int, sentenceNumber)
        self.paragraphNumber = _cast(int, paragraphNumber)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stringPositionLocator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stringPositionLocator.subclass:
            return stringPositionLocator.subclass(*args_, **kwargs_)
        else:
            return stringPositionLocator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startPosition(self): return self.startPosition
    def set_startPosition(self, startPosition): self.startPosition = startPosition
    def get_endPosition(self): return self.endPosition
    def set_endPosition(self, endPosition): self.endPosition = endPosition
    def get_sentenceNumber(self): return self.sentenceNumber
    def set_sentenceNumber(self, sentenceNumber): self.sentenceNumber = sentenceNumber
    def get_paragraphNumber(self): return self.paragraphNumber
    def set_paragraphNumber(self, paragraphNumber): self.paragraphNumber = paragraphNumber
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='stringPositionLocator', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stringPositionLocator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='stringPositionLocator', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='stringPositionLocator'):
        if self.startPosition is not None and 'startPosition' not in already_processed:
            already_processed.add('startPosition')
            outfile.write(' startPosition="%s"' % self.gds_format_integer(self.startPosition, input_name='startPosition'))
        if self.endPosition is not None and 'endPosition' not in already_processed:
            already_processed.add('endPosition')
            outfile.write(' endPosition="%s"' % self.gds_format_integer(self.endPosition, input_name='endPosition'))
        if self.sentenceNumber is not None and 'sentenceNumber' not in already_processed:
            already_processed.add('sentenceNumber')
            outfile.write(' sentenceNumber="%s"' % self.gds_format_integer(self.sentenceNumber, input_name='sentenceNumber'))
        if self.paragraphNumber is not None and 'paragraphNumber' not in already_processed:
            already_processed.add('paragraphNumber')
            outfile.write(' paragraphNumber="%s"' % self.gds_format_integer(self.paragraphNumber, input_name='paragraphNumber'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='stringPositionLocator', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('startPosition', node)
        if value is not None and 'startPosition' not in already_processed:
            already_processed.add('startPosition')
            try:
                self.startPosition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.startPosition < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('endPosition', node)
        if value is not None and 'endPosition' not in already_processed:
            already_processed.add('endPosition')
            try:
                self.endPosition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.endPosition < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('sentenceNumber', node)
        if value is not None and 'sentenceNumber' not in already_processed:
            already_processed.add('sentenceNumber')
            try:
                self.sentenceNumber = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.sentenceNumber < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('paragraphNumber', node)
        if value is not None and 'paragraphNumber' not in already_processed:
            already_processed.add('paragraphNumber')
            try:
                self.paragraphNumber = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.paragraphNumber < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class stringPositionLocator


class dataSourceRecord(GeneratedsSuper):
    """The SecurityAttributes attribute group is no longer supported by
    Palantir. It remains solely for XML parsing backwards
    compatibility. Beyond that, attributes defined in the
    SecurityAttributes attribute group are ignored."""
    subclass = None
    superclass = None
    def __init__(self, dataSource=None, importKey=None, recordLocator=None, aclId=None, classification=None, FGIsourceOpen=None, FGIsourceProtected=None, SCIcontrols=None, declassification=None, disseminationControls=None, nonICmarkings=None, nonUSmarkings=None, releasableTo=None, stringPositionLocator=None):
        self.original_tagname_ = None
        self.dataSource = _cast(None, dataSource)
        self.importKey = _cast(None, importKey)
        self.recordLocator = _cast(int, recordLocator)
        self.aclId = _cast(None, aclId)
        self.classification = _cast(None, classification)
        self.FGIsourceOpen = _cast(None, FGIsourceOpen)
        self.FGIsourceProtected = _cast(None, FGIsourceProtected)
        self.SCIcontrols = _cast(None, SCIcontrols)
        self.declassification = _cast(None, declassification)
        self.disseminationControls = _cast(None, disseminationControls)
        self.nonICmarkings = _cast(None, nonICmarkings)
        self.nonUSmarkings = _cast(None, nonUSmarkings)
        self.releasableTo = _cast(None, releasableTo)
        self.stringPositionLocator = stringPositionLocator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dataSourceRecord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dataSourceRecord.subclass:
            return dataSourceRecord.subclass(*args_, **kwargs_)
        else:
            return dataSourceRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stringPositionLocator(self): return self.stringPositionLocator
    def set_stringPositionLocator(self, stringPositionLocator): self.stringPositionLocator = stringPositionLocator
    def get_dataSource(self): return self.dataSource
    def set_dataSource(self, dataSource): self.dataSource = dataSource
    def get_importKey(self): return self.importKey
    def set_importKey(self, importKey): self.importKey = importKey
    def get_recordLocator(self): return self.recordLocator
    def set_recordLocator(self, recordLocator): self.recordLocator = recordLocator
    def get_aclId(self): return self.aclId
    def set_aclId(self, aclId): self.aclId = aclId
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def get_FGIsourceOpen(self): return self.FGIsourceOpen
    def set_FGIsourceOpen(self, FGIsourceOpen): self.FGIsourceOpen = FGIsourceOpen
    def get_FGIsourceProtected(self): return self.FGIsourceProtected
    def set_FGIsourceProtected(self, FGIsourceProtected): self.FGIsourceProtected = FGIsourceProtected
    def get_SCIcontrols(self): return self.SCIcontrols
    def set_SCIcontrols(self, SCIcontrols): self.SCIcontrols = SCIcontrols
    def get_declassification(self): return self.declassification
    def set_declassification(self, declassification): self.declassification = declassification
    def get_disseminationControls(self): return self.disseminationControls
    def set_disseminationControls(self, disseminationControls): self.disseminationControls = disseminationControls
    def get_nonICmarkings(self): return self.nonICmarkings
    def set_nonICmarkings(self, nonICmarkings): self.nonICmarkings = nonICmarkings
    def get_nonUSmarkings(self): return self.nonUSmarkings
    def set_nonUSmarkings(self, nonUSmarkings): self.nonUSmarkings = nonUSmarkings
    def get_releasableTo(self): return self.releasableTo
    def set_releasableTo(self, releasableTo): self.releasableTo = releasableTo
    def hasContent_(self):
        if (
            self.stringPositionLocator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='dataSourceRecord', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dataSourceRecord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='dataSourceRecord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='dataSourceRecord'):
        if self.dataSource is not None and 'dataSource' not in already_processed:
            already_processed.add('dataSource')
            outfile.write(' dataSource=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataSource), input_name='dataSource')), ))
        if self.importKey is not None and 'importKey' not in already_processed:
            already_processed.add('importKey')
            outfile.write(' importKey=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.importKey), input_name='importKey')), ))
        if self.recordLocator is not None and 'recordLocator' not in already_processed:
            already_processed.add('recordLocator')
            outfile.write(' recordLocator="%s"' % self.gds_format_integer(self.recordLocator, input_name='recordLocator'))
        if self.aclId is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            outfile.write(' aclId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aclId), input_name='aclId')), ))
        if self.classification is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            outfile.write(' classification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.classification), input_name='classification')), ))
        if self.FGIsourceOpen is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            outfile.write(' FGIsourceOpen=%s' % (quote_attrib(self.FGIsourceOpen), ))
        if self.FGIsourceProtected is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            outfile.write(' FGIsourceProtected=%s' % (quote_attrib(self.FGIsourceProtected), ))
        if self.SCIcontrols is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            outfile.write(' SCIcontrols=%s' % (quote_attrib(self.SCIcontrols), ))
        if self.declassification is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            outfile.write(' declassification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.declassification), input_name='declassification')), ))
        if self.disseminationControls is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            outfile.write(' disseminationControls=%s' % (quote_attrib(self.disseminationControls), ))
        if self.nonICmarkings is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            outfile.write(' nonICmarkings=%s' % (quote_attrib(self.nonICmarkings), ))
        if self.nonUSmarkings is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            outfile.write(' nonUSmarkings=%s' % (quote_attrib(self.nonUSmarkings), ))
        if self.releasableTo is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            outfile.write(' releasableTo=%s' % (quote_attrib(self.releasableTo), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='dataSourceRecord', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stringPositionLocator is not None:
            self.stringPositionLocator.export(outfile, level, namespace_, name_='stringPositionLocator', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataSource', node)
        if value is not None and 'dataSource' not in already_processed:
            already_processed.add('dataSource')
            self.dataSource = value
        value = find_attr_value_('importKey', node)
        if value is not None and 'importKey' not in already_processed:
            already_processed.add('importKey')
            self.importKey = value
        value = find_attr_value_('recordLocator', node)
        if value is not None and 'recordLocator' not in already_processed:
            already_processed.add('recordLocator')
            try:
                self.recordLocator = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('aclId', node)
        if value is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            self.aclId = value
        value = find_attr_value_('classification', node)
        if value is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            self.classification = value
            self.classification = ' '.join(self.classification.split())
        value = find_attr_value_('FGIsourceOpen', node)
        if value is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            self.FGIsourceOpen = value
        value = find_attr_value_('FGIsourceProtected', node)
        if value is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            self.FGIsourceProtected = value
        value = find_attr_value_('SCIcontrols', node)
        if value is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            self.SCIcontrols = value
        value = find_attr_value_('declassification', node)
        if value is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            self.declassification = value
        value = find_attr_value_('disseminationControls', node)
        if value is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            self.disseminationControls = value
        value = find_attr_value_('nonICmarkings', node)
        if value is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            self.nonICmarkings = value
        value = find_attr_value_('nonUSmarkings', node)
        if value is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            self.nonUSmarkings = value
        value = find_attr_value_('releasableTo', node)
        if value is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            self.releasableTo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stringPositionLocator':
            obj_ = stringPositionLocator.factory()
            obj_.build(child_)
            self.stringPositionLocator = obj_
            obj_.original_tagname_ = 'stringPositionLocator'
# end class dataSourceRecord


class dataSourceRecordSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dataSourceRecord=None):
        self.original_tagname_ = None
        if dataSourceRecord is None:
            self.dataSourceRecord = []
        else:
            self.dataSourceRecord = dataSourceRecord
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dataSourceRecordSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dataSourceRecordSet.subclass:
            return dataSourceRecordSet.subclass(*args_, **kwargs_)
        else:
            return dataSourceRecordSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataSourceRecord(self): return self.dataSourceRecord
    def set_dataSourceRecord(self, dataSourceRecord): self.dataSourceRecord = dataSourceRecord
    def add_dataSourceRecord(self, value): self.dataSourceRecord.append(value)
    def insert_dataSourceRecord_at(self, index, value): self.dataSourceRecord.insert(index, value)
    def replace_dataSourceRecord_at(self, index, value): self.dataSourceRecord[index] = value
    def hasContent_(self):
        if (
            self.dataSourceRecord
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='dataSourceRecordSet', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dataSourceRecordSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='dataSourceRecordSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='dataSourceRecordSet'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='dataSourceRecordSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dataSourceRecord_ in self.dataSourceRecord:
            dataSourceRecord_.export(outfile, level, namespace_, name_='dataSourceRecord', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dataSourceRecord':
            obj_ = dataSourceRecord.factory()
            obj_.build(child_)
            self.dataSourceRecord.append(obj_)
            obj_.original_tagname_ = 'dataSourceRecord'
# end class dataSourceRecordSet


class property(GeneratedsSuper):
    """The SecurityAttributes attribute group is no longer supported by
    Palantir. It remains solely for XML parsing backwards
    compatibility. Beyond that, attributes defined in the
    SecurityAttributes attribute group are ignored."""
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, linkType=None, role=None, keywordDisabled=None, aclId=None, classification=None, FGIsourceOpen=None, FGIsourceProtected=None, SCIcontrols=None, declassification=None, disseminationControls=None, nonICmarkings=None, nonUSmarkings=None, releasableTo=None, customKeyword=None, timestamp=None, timeInterval=None, gisData=None, propertyValue=None, dataSourceRecordSet=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.type_ = _cast(None, type_)
        self.linkType = _cast(None, linkType)
        self.role = _cast(None, role)
        self.keywordDisabled = _cast(bool, keywordDisabled)
        self.aclId = _cast(None, aclId)
        self.classification = _cast(None, classification)
        self.FGIsourceOpen = _cast(None, FGIsourceOpen)
        self.FGIsourceProtected = _cast(None, FGIsourceProtected)
        self.SCIcontrols = _cast(None, SCIcontrols)
        self.declassification = _cast(None, declassification)
        self.disseminationControls = _cast(None, disseminationControls)
        self.nonICmarkings = _cast(None, nonICmarkings)
        self.nonUSmarkings = _cast(None, nonUSmarkings)
        self.releasableTo = _cast(None, releasableTo)
        self.customKeyword = customKeyword
        self.validate_customKeyword(self.customKeyword)
        self.timestamp = timestamp
        self.timeInterval = timeInterval
        self.gisData = gisData
        self.propertyValue = propertyValue
        self.dataSourceRecordSet = dataSourceRecordSet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, property)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if property.subclass:
            return property.subclass(*args_, **kwargs_)
        else:
            return property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_customKeyword(self): return self.customKeyword
    def set_customKeyword(self, customKeyword): self.customKeyword = customKeyword
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_timeInterval(self): return self.timeInterval
    def set_timeInterval(self, timeInterval): self.timeInterval = timeInterval
    def get_gisData(self): return self.gisData
    def set_gisData(self, gisData): self.gisData = gisData
    def get_propertyValue(self): return self.propertyValue
    def set_propertyValue(self, propertyValue): self.propertyValue = propertyValue
    def get_dataSourceRecordSet(self): return self.dataSourceRecordSet
    def set_dataSourceRecordSet(self, dataSourceRecordSet): self.dataSourceRecordSet = dataSourceRecordSet
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_linkType(self): return self.linkType
    def set_linkType(self, linkType): self.linkType = linkType
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_keywordDisabled(self): return self.keywordDisabled
    def set_keywordDisabled(self, keywordDisabled): self.keywordDisabled = keywordDisabled
    def get_aclId(self): return self.aclId
    def set_aclId(self, aclId): self.aclId = aclId
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def get_FGIsourceOpen(self): return self.FGIsourceOpen
    def set_FGIsourceOpen(self, FGIsourceOpen): self.FGIsourceOpen = FGIsourceOpen
    def get_FGIsourceProtected(self): return self.FGIsourceProtected
    def set_FGIsourceProtected(self, FGIsourceProtected): self.FGIsourceProtected = FGIsourceProtected
    def get_SCIcontrols(self): return self.SCIcontrols
    def set_SCIcontrols(self, SCIcontrols): self.SCIcontrols = SCIcontrols
    def get_declassification(self): return self.declassification
    def set_declassification(self, declassification): self.declassification = declassification
    def get_disseminationControls(self): return self.disseminationControls
    def set_disseminationControls(self, disseminationControls): self.disseminationControls = disseminationControls
    def get_nonICmarkings(self): return self.nonICmarkings
    def set_nonICmarkings(self, nonICmarkings): self.nonICmarkings = nonICmarkings
    def get_nonUSmarkings(self): return self.nonUSmarkings
    def set_nonUSmarkings(self, nonUSmarkings): self.nonUSmarkings = nonUSmarkings
    def get_releasableTo(self): return self.releasableTo
    def set_releasableTo(self, releasableTo): self.releasableTo = releasableTo
    def validate_customKeyword(self, value):
        # Validate type customKeyword, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.customKeyword is not None or
            self.timestamp is not None or
            self.timeInterval is not None or
            self.gisData is not None or
            self.propertyValue is not None or
            self.dataSourceRecordSet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='property', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='property')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='property', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='property'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.linkType is not None and 'linkType' not in already_processed:
            already_processed.add('linkType')
            outfile.write(' linkType=%s' % (quote_attrib(self.linkType), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.keywordDisabled is not None and 'keywordDisabled' not in already_processed:
            already_processed.add('keywordDisabled')
            outfile.write(' keywordDisabled="%s"' % self.gds_format_boolean(self.keywordDisabled, input_name='keywordDisabled'))
        if self.aclId is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            outfile.write(' aclId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aclId), input_name='aclId')), ))
        if self.classification is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            outfile.write(' classification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.classification), input_name='classification')), ))
        if self.FGIsourceOpen is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            outfile.write(' FGIsourceOpen=%s' % (quote_attrib(self.FGIsourceOpen), ))
        if self.FGIsourceProtected is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            outfile.write(' FGIsourceProtected=%s' % (quote_attrib(self.FGIsourceProtected), ))
        if self.SCIcontrols is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            outfile.write(' SCIcontrols=%s' % (quote_attrib(self.SCIcontrols), ))
        if self.declassification is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            outfile.write(' declassification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.declassification), input_name='declassification')), ))
        if self.disseminationControls is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            outfile.write(' disseminationControls=%s' % (quote_attrib(self.disseminationControls), ))
        if self.nonICmarkings is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            outfile.write(' nonICmarkings=%s' % (quote_attrib(self.nonICmarkings), ))
        if self.nonUSmarkings is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            outfile.write(' nonUSmarkings=%s' % (quote_attrib(self.nonUSmarkings), ))
        if self.releasableTo is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            outfile.write(' releasableTo=%s' % (quote_attrib(self.releasableTo), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='property', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.customKeyword is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomKeyword>%s</%scustomKeyword>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.customKeyword), input_name='customKeyword')), namespace_, eol_))
        if self.timestamp is not None:
            self.timestamp.export(outfile, level, namespace_, name_='timestamp', pretty_print=pretty_print)
        if self.timeInterval is not None:
            self.timeInterval.export(outfile, level, namespace_, name_='timeInterval', pretty_print=pretty_print)
        if self.gisData is not None:
            self.gisData.export(outfile, level, namespace_, name_='gisData', pretty_print=pretty_print)
        if self.propertyValue is not None:
            self.propertyValue.export(outfile, level, namespace_, name_='propertyValue', pretty_print=pretty_print)
        if self.dataSourceRecordSet is not None:
            self.dataSourceRecordSet.export(outfile, level, namespace_, name_='dataSourceRecordSet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('linkType', node)
        if value is not None and 'linkType' not in already_processed:
            already_processed.add('linkType')
            self.linkType = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('keywordDisabled', node)
        if value is not None and 'keywordDisabled' not in already_processed:
            already_processed.add('keywordDisabled')
            if value in ('true', '1'):
                self.keywordDisabled = True
            elif value in ('false', '0'):
                self.keywordDisabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('aclId', node)
        if value is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            self.aclId = value
        value = find_attr_value_('classification', node)
        if value is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            self.classification = value
            self.classification = ' '.join(self.classification.split())
        value = find_attr_value_('FGIsourceOpen', node)
        if value is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            self.FGIsourceOpen = value
        value = find_attr_value_('FGIsourceProtected', node)
        if value is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            self.FGIsourceProtected = value
        value = find_attr_value_('SCIcontrols', node)
        if value is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            self.SCIcontrols = value
        value = find_attr_value_('declassification', node)
        if value is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            self.declassification = value
        value = find_attr_value_('disseminationControls', node)
        if value is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            self.disseminationControls = value
        value = find_attr_value_('nonICmarkings', node)
        if value is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            self.nonICmarkings = value
        value = find_attr_value_('nonUSmarkings', node)
        if value is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            self.nonUSmarkings = value
        value = find_attr_value_('releasableTo', node)
        if value is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            self.releasableTo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'customKeyword':
            customKeyword_ = child_.text
            customKeyword_ = self.gds_validate_string(customKeyword_, node, 'customKeyword')
            self.customKeyword = customKeyword_
            # validate type customKeyword
            self.validate_customKeyword(self.customKeyword)
        elif nodeName_ == 'timestamp':
            obj_ = timestamp.factory()
            obj_.build(child_)
            self.timestamp = obj_
            obj_.original_tagname_ = 'timestamp'
        elif nodeName_ == 'timeInterval':
            obj_ = timeInterval.factory()
            obj_.build(child_)
            self.timeInterval = obj_
            obj_.original_tagname_ = 'timeInterval'
        elif nodeName_ == 'gisData':
            obj_ = gisData.factory()
            obj_.build(child_)
            self.gisData = obj_
            obj_.original_tagname_ = 'gisData'
        elif nodeName_ == 'propertyValue':
            obj_ = propertyValue.factory()
            obj_.build(child_)
            self.propertyValue = obj_
            obj_.original_tagname_ = 'propertyValue'
        elif nodeName_ == 'dataSourceRecordSet':
            obj_ = dataSourceRecordSet.factory()
            obj_.build(child_)
            self.dataSourceRecordSet = obj_
            obj_.original_tagname_ = 'dataSourceRecordSet'
# end class property


class propertyComponent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, propertyData=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.propertyData = propertyData
        self.validate_propertyData(self.propertyData)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyComponent.subclass:
            return propertyComponent.subclass(*args_, **kwargs_)
        else:
            return propertyComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_propertyData(self): return self.propertyData
    def set_propertyData(self, propertyData): self.propertyData = propertyData
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_propertyData(self, value):
        # Validate type propertyData, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.propertyData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='propertyComponent', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='propertyComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='propertyComponent'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='propertyComponent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.propertyData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spropertyData>%s</%spropertyData>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.propertyData), input_name='propertyData')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'propertyData':
            propertyData_ = child_.text
            propertyData_ = self.gds_validate_string(propertyData_, node, 'propertyData')
            self.propertyData = propertyData_
            # validate type propertyData
            self.validate_propertyData(self.propertyData)
# end class propertyComponent


class propertyValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, propertyData=None, propertyComponent=None, propertyTimeInterval=None, propertyUnparsedValue=None, propertyRawValue=None):
        self.original_tagname_ = None
        self.propertyData = propertyData
        self.validate_propertyData(self.propertyData)
        if propertyComponent is None:
            self.propertyComponent = []
        else:
            self.propertyComponent = propertyComponent
        self.propertyTimeInterval = propertyTimeInterval
        self.propertyUnparsedValue = propertyUnparsedValue
        self.propertyRawValue = propertyRawValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyValue.subclass:
            return propertyValue.subclass(*args_, **kwargs_)
        else:
            return propertyValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_propertyData(self): return self.propertyData
    def set_propertyData(self, propertyData): self.propertyData = propertyData
    def get_propertyComponent(self): return self.propertyComponent
    def set_propertyComponent(self, propertyComponent): self.propertyComponent = propertyComponent
    def add_propertyComponent(self, value): self.propertyComponent.append(value)
    def insert_propertyComponent_at(self, index, value): self.propertyComponent.insert(index, value)
    def replace_propertyComponent_at(self, index, value): self.propertyComponent[index] = value
    def get_propertyTimeInterval(self): return self.propertyTimeInterval
    def set_propertyTimeInterval(self, propertyTimeInterval): self.propertyTimeInterval = propertyTimeInterval
    def get_propertyUnparsedValue(self): return self.propertyUnparsedValue
    def set_propertyUnparsedValue(self, propertyUnparsedValue): self.propertyUnparsedValue = propertyUnparsedValue
    def get_propertyRawValue(self): return self.propertyRawValue
    def set_propertyRawValue(self, propertyRawValue): self.propertyRawValue = propertyRawValue
    def validate_propertyData(self, value):
        # Validate type propertyData, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.propertyData is not None or
            self.propertyComponent or
            self.propertyTimeInterval is not None or
            self.propertyUnparsedValue is not None or
            self.propertyRawValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='propertyValue', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='propertyValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='propertyValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='propertyValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.propertyData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spropertyData>%s</%spropertyData>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.propertyData), input_name='propertyData')), namespace_, eol_))
        for propertyComponent_ in self.propertyComponent:
            propertyComponent_.export(outfile, level, namespace_, name_='propertyComponent', pretty_print=pretty_print)
        if self.propertyTimeInterval is not None:
            self.propertyTimeInterval.export(outfile, level, namespace_, name_='propertyTimeInterval', pretty_print=pretty_print)
        if self.propertyUnparsedValue is not None:
            self.propertyUnparsedValue.export(outfile, level, namespace_, name_='propertyUnparsedValue', pretty_print=pretty_print)
        if self.propertyRawValue is not None:
            self.propertyRawValue.export(outfile, level, namespace_, name_='propertyRawValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'propertyData':
            propertyData_ = child_.text
            propertyData_ = self.gds_validate_string(propertyData_, node, 'propertyData')
            self.propertyData = propertyData_
            # validate type propertyData
            self.validate_propertyData(self.propertyData)
        elif nodeName_ == 'propertyComponent':
            obj_ = propertyComponent.factory()
            obj_.build(child_)
            self.propertyComponent.append(obj_)
            obj_.original_tagname_ = 'propertyComponent'
        elif nodeName_ == 'propertyTimeInterval':
            obj_ = propertyTimeInterval.factory()
            obj_.build(child_)
            self.propertyTimeInterval = obj_
            obj_.original_tagname_ = 'propertyTimeInterval'
        elif nodeName_ == 'propertyUnparsedValue':
            obj_ = propertyUnparsedValue.factory()
            obj_.build(child_)
            self.propertyUnparsedValue = obj_
            obj_.original_tagname_ = 'propertyUnparsedValue'
        elif nodeName_ == 'propertyRawValue':
            obj_ = propertyRawValue.factory()
            obj_.build(child_)
            self.propertyRawValue = obj_
            obj_.original_tagname_ = 'propertyRawValue'
# end class propertyValue


class propertySet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None):
        self.original_tagname_ = None
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertySet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertySet.subclass:
            return propertySet.subclass(*args_, **kwargs_)
        else:
            return propertySet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def hasContent_(self):
        if (
            self.property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='propertySet', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertySet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='propertySet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='propertySet'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='propertySet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = property.factory()
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
# end class propertySet


class mediaSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, media=None):
        self.original_tagname_ = None
        if media is None:
            self.media = []
        else:
            self.media = media
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mediaSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mediaSet.subclass:
            return mediaSet.subclass(*args_, **kwargs_)
        else:
            return mediaSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_media(self): return self.media
    def set_media(self, media): self.media = media
    def add_media(self, value): self.media.append(value)
    def insert_media_at(self, index, value): self.media.insert(index, value)
    def replace_media_at(self, index, value): self.media[index] = value
    def hasContent_(self):
        if (
            self.media
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='mediaSet', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mediaSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='mediaSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='mediaSet'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='mediaSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for media_ in self.media:
            media_.export(outfile, level, namespace_, name_='media', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'media':
            obj_ = media.factory()
            obj_.build(child_)
            self.media.append(obj_)
            obj_.original_tagname_ = 'media'
# end class mediaSet


class media(GeneratedsSuper):
    """The SecurityAttributes attribute group is no longer supported by
    Palantir. It remains solely for XML parsing backwards
    compatibility. Beyond that, attributes defined in the
    SecurityAttributes attribute group are ignored."""
    subclass = None
    superclass = None
    def __init__(self, id=None, mediaType=None, linkType=None, mimeType=None, filename=None, aclId=None, classification=None, FGIsourceOpen=None, FGIsourceProtected=None, SCIcontrols=None, declassification=None, disseminationControls=None, nonICmarkings=None, nonUSmarkings=None, releasableTo=None, mediaTitle=None, mediaShortDescription=None, mediaDescription=None, mediaData=None, thumbnail=None, dataSourceRecordSet=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.mediaType = _cast(None, mediaType)
        self.linkType = _cast(None, linkType)
        self.mimeType = _cast(None, mimeType)
        self.filename = _cast(None, filename)
        self.aclId = _cast(None, aclId)
        self.classification = _cast(None, classification)
        self.FGIsourceOpen = _cast(None, FGIsourceOpen)
        self.FGIsourceProtected = _cast(None, FGIsourceProtected)
        self.SCIcontrols = _cast(None, SCIcontrols)
        self.declassification = _cast(None, declassification)
        self.disseminationControls = _cast(None, disseminationControls)
        self.nonICmarkings = _cast(None, nonICmarkings)
        self.nonUSmarkings = _cast(None, nonUSmarkings)
        self.releasableTo = _cast(None, releasableTo)
        self.mediaTitle = mediaTitle
        self.validate_mediaTitleType(self.mediaTitle)
        self.mediaShortDescription = mediaShortDescription
        self.validate_mediaShortDescriptionType(self.mediaShortDescription)
        self.mediaDescription = mediaDescription
        self.validate_mediaDescriptionType(self.mediaDescription)
        self.mediaData = mediaData
        self.validate_mediaData(self.mediaData)
        self.thumbnail = thumbnail
        self.dataSourceRecordSet = dataSourceRecordSet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, media)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if media.subclass:
            return media.subclass(*args_, **kwargs_)
        else:
            return media(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mediaTitle(self): return self.mediaTitle
    def set_mediaTitle(self, mediaTitle): self.mediaTitle = mediaTitle
    def get_mediaShortDescription(self): return self.mediaShortDescription
    def set_mediaShortDescription(self, mediaShortDescription): self.mediaShortDescription = mediaShortDescription
    def get_mediaDescription(self): return self.mediaDescription
    def set_mediaDescription(self, mediaDescription): self.mediaDescription = mediaDescription
    def get_mediaData(self): return self.mediaData
    def set_mediaData(self, mediaData): self.mediaData = mediaData
    def get_thumbnail(self): return self.thumbnail
    def set_thumbnail(self, thumbnail): self.thumbnail = thumbnail
    def get_dataSourceRecordSet(self): return self.dataSourceRecordSet
    def set_dataSourceRecordSet(self, dataSourceRecordSet): self.dataSourceRecordSet = dataSourceRecordSet
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_mediaType(self): return self.mediaType
    def set_mediaType(self, mediaType): self.mediaType = mediaType
    def get_linkType(self): return self.linkType
    def set_linkType(self, linkType): self.linkType = linkType
    def get_mimeType(self): return self.mimeType
    def set_mimeType(self, mimeType): self.mimeType = mimeType
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def get_aclId(self): return self.aclId
    def set_aclId(self, aclId): self.aclId = aclId
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def get_FGIsourceOpen(self): return self.FGIsourceOpen
    def set_FGIsourceOpen(self, FGIsourceOpen): self.FGIsourceOpen = FGIsourceOpen
    def get_FGIsourceProtected(self): return self.FGIsourceProtected
    def set_FGIsourceProtected(self, FGIsourceProtected): self.FGIsourceProtected = FGIsourceProtected
    def get_SCIcontrols(self): return self.SCIcontrols
    def set_SCIcontrols(self, SCIcontrols): self.SCIcontrols = SCIcontrols
    def get_declassification(self): return self.declassification
    def set_declassification(self, declassification): self.declassification = declassification
    def get_disseminationControls(self): return self.disseminationControls
    def set_disseminationControls(self, disseminationControls): self.disseminationControls = disseminationControls
    def get_nonICmarkings(self): return self.nonICmarkings
    def set_nonICmarkings(self, nonICmarkings): self.nonICmarkings = nonICmarkings
    def get_nonUSmarkings(self): return self.nonUSmarkings
    def set_nonUSmarkings(self, nonUSmarkings): self.nonUSmarkings = nonUSmarkings
    def get_releasableTo(self): return self.releasableTo
    def set_releasableTo(self, releasableTo): self.releasableTo = releasableTo
    def validate_mediaTitleType(self, value):
        # Validate type mediaTitleType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 80:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on mediaTitleType' % {"value" : value.encode("utf-8")} )
    def validate_mediaShortDescriptionType(self, value):
        # Validate type mediaShortDescriptionType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on mediaShortDescriptionType' % {"value" : value.encode("utf-8")} )
    def validate_mediaDescriptionType(self, value):
        # Validate type mediaDescriptionType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on mediaDescriptionType' % {"value" : value.encode("utf-8")} )
    def validate_mediaData(self, value):
        # Validate type mediaData, a restriction on xsd:base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.mediaTitle is not None or
            self.mediaShortDescription is not None or
            self.mediaDescription is not None or
            self.mediaData is not None or
            self.thumbnail is not None or
            self.dataSourceRecordSet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='media', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='media')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='media', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='media'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.mediaType is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (quote_attrib(self.mediaType), ))
        if self.linkType is not None and 'linkType' not in already_processed:
            already_processed.add('linkType')
            outfile.write(' linkType=%s' % (quote_attrib(self.linkType), ))
        if self.mimeType is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            outfile.write(' mimeType=%s' % (quote_attrib(self.mimeType), ))
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filename), input_name='filename')), ))
        if self.aclId is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            outfile.write(' aclId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aclId), input_name='aclId')), ))
        if self.classification is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            outfile.write(' classification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.classification), input_name='classification')), ))
        if self.FGIsourceOpen is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            outfile.write(' FGIsourceOpen=%s' % (quote_attrib(self.FGIsourceOpen), ))
        if self.FGIsourceProtected is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            outfile.write(' FGIsourceProtected=%s' % (quote_attrib(self.FGIsourceProtected), ))
        if self.SCIcontrols is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            outfile.write(' SCIcontrols=%s' % (quote_attrib(self.SCIcontrols), ))
        if self.declassification is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            outfile.write(' declassification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.declassification), input_name='declassification')), ))
        if self.disseminationControls is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            outfile.write(' disseminationControls=%s' % (quote_attrib(self.disseminationControls), ))
        if self.nonICmarkings is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            outfile.write(' nonICmarkings=%s' % (quote_attrib(self.nonICmarkings), ))
        if self.nonUSmarkings is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            outfile.write(' nonUSmarkings=%s' % (quote_attrib(self.nonUSmarkings), ))
        if self.releasableTo is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            outfile.write(' releasableTo=%s' % (quote_attrib(self.releasableTo), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='media', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mediaTitle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smediaTitle>%s</%smediaTitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.mediaTitle), input_name='mediaTitle')), namespace_, eol_))
        if self.mediaShortDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smediaShortDescription>%s</%smediaShortDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.mediaShortDescription), input_name='mediaShortDescription')), namespace_, eol_))
        if self.mediaDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smediaDescription>%s</%smediaDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.mediaDescription), input_name='mediaDescription')), namespace_, eol_))
        if self.mediaData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smediaData>%s</%smediaData>%s' % (namespace_, self.gds_format_base64(self.mediaData, input_name='mediaData'), namespace_, eol_))
        if self.thumbnail is not None:
            self.thumbnail.export(outfile, level, namespace_, name_='thumbnail', pretty_print=pretty_print)
        if self.dataSourceRecordSet is not None:
            self.dataSourceRecordSet.export(outfile, level, namespace_, name_='dataSourceRecordSet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
        value = find_attr_value_('linkType', node)
        if value is not None and 'linkType' not in already_processed:
            already_processed.add('linkType')
            self.linkType = value
        value = find_attr_value_('mimeType', node)
        if value is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            self.mimeType = value
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
        value = find_attr_value_('aclId', node)
        if value is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            self.aclId = value
        value = find_attr_value_('classification', node)
        if value is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            self.classification = value
            self.classification = ' '.join(self.classification.split())
        value = find_attr_value_('FGIsourceOpen', node)
        if value is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            self.FGIsourceOpen = value
        value = find_attr_value_('FGIsourceProtected', node)
        if value is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            self.FGIsourceProtected = value
        value = find_attr_value_('SCIcontrols', node)
        if value is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            self.SCIcontrols = value
        value = find_attr_value_('declassification', node)
        if value is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            self.declassification = value
        value = find_attr_value_('disseminationControls', node)
        if value is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            self.disseminationControls = value
        value = find_attr_value_('nonICmarkings', node)
        if value is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            self.nonICmarkings = value
        value = find_attr_value_('nonUSmarkings', node)
        if value is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            self.nonUSmarkings = value
        value = find_attr_value_('releasableTo', node)
        if value is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            self.releasableTo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mediaTitle':
            mediaTitle_ = child_.text
            mediaTitle_ = self.gds_validate_string(mediaTitle_, node, 'mediaTitle')
            self.mediaTitle = mediaTitle_
            # validate type mediaTitleType
            self.validate_mediaTitleType(self.mediaTitle)
        elif nodeName_ == 'mediaShortDescription':
            mediaShortDescription_ = child_.text
            mediaShortDescription_ = self.gds_validate_string(mediaShortDescription_, node, 'mediaShortDescription')
            self.mediaShortDescription = mediaShortDescription_
            # validate type mediaShortDescriptionType
            self.validate_mediaShortDescriptionType(self.mediaShortDescription)
        elif nodeName_ == 'mediaDescription':
            mediaDescription_ = child_.text
            mediaDescription_ = self.gds_validate_string(mediaDescription_, node, 'mediaDescription')
            self.mediaDescription = mediaDescription_
            # validate type mediaDescriptionType
            self.validate_mediaDescriptionType(self.mediaDescription)
        elif nodeName_ == 'mediaData':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'mediaData')
            else:
                bval_ = None
            self.mediaData = bval_
            # validate type mediaData
            self.validate_mediaData(self.mediaData)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnailType.factory()
            obj_.build(child_)
            self.thumbnail = obj_
            obj_.original_tagname_ = 'thumbnail'
        elif nodeName_ == 'dataSourceRecordSet':
            obj_ = dataSourceRecordSet.factory()
            obj_.build(child_)
            self.dataSourceRecordSet = obj_
            obj_.original_tagname_ = 'dataSourceRecordSet'
# end class media


class note(GeneratedsSuper):
    """The SecurityAttributes attribute group is no longer supported by
    Palantir. It remains solely for XML parsing backwards
    compatibility. Beyond that, attributes defined in the
    SecurityAttributes attribute group are ignored."""
    subclass = None
    superclass = None
    def __init__(self, linkType=None, aclId=None, id=None, classification=None, FGIsourceOpen=None, FGIsourceProtected=None, SCIcontrols=None, declassification=None, disseminationControls=None, nonICmarkings=None, nonUSmarkings=None, releasableTo=None, noteTitle=None, noteData=None, dataSourceRecordSet=None):
        self.original_tagname_ = None
        self.linkType = _cast(None, linkType)
        self.aclId = _cast(None, aclId)
        self.id = _cast(None, id)
        self.classification = _cast(None, classification)
        self.FGIsourceOpen = _cast(None, FGIsourceOpen)
        self.FGIsourceProtected = _cast(None, FGIsourceProtected)
        self.SCIcontrols = _cast(None, SCIcontrols)
        self.declassification = _cast(None, declassification)
        self.disseminationControls = _cast(None, disseminationControls)
        self.nonICmarkings = _cast(None, nonICmarkings)
        self.nonUSmarkings = _cast(None, nonUSmarkings)
        self.releasableTo = _cast(None, releasableTo)
        self.noteTitle = noteTitle
        self.validate_noteTitleType(self.noteTitle)
        self.noteData = noteData
        self.validate_noteDataType(self.noteData)
        self.dataSourceRecordSet = dataSourceRecordSet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, note)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if note.subclass:
            return note.subclass(*args_, **kwargs_)
        else:
            return note(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_noteTitle(self): return self.noteTitle
    def set_noteTitle(self, noteTitle): self.noteTitle = noteTitle
    def get_noteData(self): return self.noteData
    def set_noteData(self, noteData): self.noteData = noteData
    def get_dataSourceRecordSet(self): return self.dataSourceRecordSet
    def set_dataSourceRecordSet(self, dataSourceRecordSet): self.dataSourceRecordSet = dataSourceRecordSet
    def get_linkType(self): return self.linkType
    def set_linkType(self, linkType): self.linkType = linkType
    def get_aclId(self): return self.aclId
    def set_aclId(self, aclId): self.aclId = aclId
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def get_FGIsourceOpen(self): return self.FGIsourceOpen
    def set_FGIsourceOpen(self, FGIsourceOpen): self.FGIsourceOpen = FGIsourceOpen
    def get_FGIsourceProtected(self): return self.FGIsourceProtected
    def set_FGIsourceProtected(self, FGIsourceProtected): self.FGIsourceProtected = FGIsourceProtected
    def get_SCIcontrols(self): return self.SCIcontrols
    def set_SCIcontrols(self, SCIcontrols): self.SCIcontrols = SCIcontrols
    def get_declassification(self): return self.declassification
    def set_declassification(self, declassification): self.declassification = declassification
    def get_disseminationControls(self): return self.disseminationControls
    def set_disseminationControls(self, disseminationControls): self.disseminationControls = disseminationControls
    def get_nonICmarkings(self): return self.nonICmarkings
    def set_nonICmarkings(self, nonICmarkings): self.nonICmarkings = nonICmarkings
    def get_nonUSmarkings(self): return self.nonUSmarkings
    def set_nonUSmarkings(self, nonUSmarkings): self.nonUSmarkings = nonUSmarkings
    def get_releasableTo(self): return self.releasableTo
    def set_releasableTo(self, releasableTo): self.releasableTo = releasableTo
    def validate_noteTitleType(self, value):
        # Validate type noteTitleType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 80:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on noteTitleType' % {"value" : value.encode("utf-8")} )
    def validate_noteDataType(self, value):
        # Validate type noteDataType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.noteTitle is not None or
            self.noteData is not None or
            self.dataSourceRecordSet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='note', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='note')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='note', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='note'):
        if self.linkType is not None and 'linkType' not in already_processed:
            already_processed.add('linkType')
            outfile.write(' linkType=%s' % (quote_attrib(self.linkType), ))
        if self.aclId is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            outfile.write(' aclId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aclId), input_name='aclId')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.classification is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            outfile.write(' classification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.classification), input_name='classification')), ))
        if self.FGIsourceOpen is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            outfile.write(' FGIsourceOpen=%s' % (quote_attrib(self.FGIsourceOpen), ))
        if self.FGIsourceProtected is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            outfile.write(' FGIsourceProtected=%s' % (quote_attrib(self.FGIsourceProtected), ))
        if self.SCIcontrols is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            outfile.write(' SCIcontrols=%s' % (quote_attrib(self.SCIcontrols), ))
        if self.declassification is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            outfile.write(' declassification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.declassification), input_name='declassification')), ))
        if self.disseminationControls is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            outfile.write(' disseminationControls=%s' % (quote_attrib(self.disseminationControls), ))
        if self.nonICmarkings is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            outfile.write(' nonICmarkings=%s' % (quote_attrib(self.nonICmarkings), ))
        if self.nonUSmarkings is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            outfile.write(' nonUSmarkings=%s' % (quote_attrib(self.nonUSmarkings), ))
        if self.releasableTo is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            outfile.write(' releasableTo=%s' % (quote_attrib(self.releasableTo), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='note', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.noteTitle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snoteTitle>%s</%snoteTitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.noteTitle), input_name='noteTitle')), namespace_, eol_))
        if self.noteData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snoteData>%s</%snoteData>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.noteData), input_name='noteData')), namespace_, eol_))
        if self.dataSourceRecordSet is not None:
            self.dataSourceRecordSet.export(outfile, level, namespace_, name_='dataSourceRecordSet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('linkType', node)
        if value is not None and 'linkType' not in already_processed:
            already_processed.add('linkType')
            self.linkType = value
        value = find_attr_value_('aclId', node)
        if value is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            self.aclId = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('classification', node)
        if value is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            self.classification = value
            self.classification = ' '.join(self.classification.split())
        value = find_attr_value_('FGIsourceOpen', node)
        if value is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            self.FGIsourceOpen = value
        value = find_attr_value_('FGIsourceProtected', node)
        if value is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            self.FGIsourceProtected = value
        value = find_attr_value_('SCIcontrols', node)
        if value is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            self.SCIcontrols = value
        value = find_attr_value_('declassification', node)
        if value is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            self.declassification = value
        value = find_attr_value_('disseminationControls', node)
        if value is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            self.disseminationControls = value
        value = find_attr_value_('nonICmarkings', node)
        if value is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            self.nonICmarkings = value
        value = find_attr_value_('nonUSmarkings', node)
        if value is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            self.nonUSmarkings = value
        value = find_attr_value_('releasableTo', node)
        if value is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            self.releasableTo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'noteTitle':
            noteTitle_ = child_.text
            noteTitle_ = self.gds_validate_string(noteTitle_, node, 'noteTitle')
            self.noteTitle = noteTitle_
            # validate type noteTitleType
            self.validate_noteTitleType(self.noteTitle)
        elif nodeName_ == 'noteData':
            noteData_ = child_.text
            noteData_ = self.gds_validate_string(noteData_, node, 'noteData')
            self.noteData = noteData_
            # validate type noteDataType
            self.validate_noteDataType(self.noteData)
        elif nodeName_ == 'dataSourceRecordSet':
            obj_ = dataSourceRecordSet.factory()
            obj_.build(child_)
            self.dataSourceRecordSet = obj_
            obj_.original_tagname_ = 'dataSourceRecordSet'
# end class note


class object(GeneratedsSuper):
    """The SecurityAttributes attribute group is no longer supported by
    Palantir. It remains solely for XML parsing backwards
    compatibility. Beyond that, attributes defined in the
    SecurityAttributes attribute group are ignored."""
    subclass = None
    superclass = None
    def __init__(self, id=None, externalId=None, resolvesTo=None, type_=None, baseType=None, timeStart=None, timeEnd=None, groupFlag=False, classification=None, FGIsourceOpen=None, FGIsourceProtected=None, SCIcontrols=None, declassification=None, disseminationControls=None, nonICmarkings=None, nonUSmarkings=None, releasableTo=None, title=None, description=None, propertySet=None, mediaSet=None, noteSet=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.externalId = _cast(None, externalId)
        self.resolvesTo = _cast(None, resolvesTo)
        self.type_ = _cast(None, type_)
        self.baseType = _cast(None, baseType)
        if isinstance(timeStart, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timeStart, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timeStart
        self.timeStart = initvalue_
        if isinstance(timeEnd, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timeEnd, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timeEnd
        self.timeEnd = initvalue_
        self.groupFlag = _cast(bool, groupFlag)
        self.classification = _cast(None, classification)
        self.FGIsourceOpen = _cast(None, FGIsourceOpen)
        self.FGIsourceProtected = _cast(None, FGIsourceProtected)
        self.SCIcontrols = _cast(None, SCIcontrols)
        self.declassification = _cast(None, declassification)
        self.disseminationControls = _cast(None, disseminationControls)
        self.nonICmarkings = _cast(None, nonICmarkings)
        self.nonUSmarkings = _cast(None, nonUSmarkings)
        self.releasableTo = _cast(None, releasableTo)
        self.title = title
        self.validate_titleType(self.title)
        self.description = description
        self.validate_descriptionType(self.description)
        self.propertySet = propertySet
        self.mediaSet = mediaSet
        self.noteSet = noteSet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, object)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if object.subclass:
            return object.subclass(*args_, **kwargs_)
        else:
            return object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_propertySet(self): return self.propertySet
    def set_propertySet(self, propertySet): self.propertySet = propertySet
    def get_mediaSet(self): return self.mediaSet
    def set_mediaSet(self, mediaSet): self.mediaSet = mediaSet
    def get_noteSet(self): return self.noteSet
    def set_noteSet(self, noteSet): self.noteSet = noteSet
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_externalId(self): return self.externalId
    def set_externalId(self, externalId): self.externalId = externalId
    def get_resolvesTo(self): return self.resolvesTo
    def set_resolvesTo(self, resolvesTo): self.resolvesTo = resolvesTo
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_baseType(self): return self.baseType
    def set_baseType(self, baseType): self.baseType = baseType
    def get_timeStart(self): return self.timeStart
    def set_timeStart(self, timeStart): self.timeStart = timeStart
    def get_timeEnd(self): return self.timeEnd
    def set_timeEnd(self, timeEnd): self.timeEnd = timeEnd
    def get_groupFlag(self): return self.groupFlag
    def set_groupFlag(self, groupFlag): self.groupFlag = groupFlag
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def get_FGIsourceOpen(self): return self.FGIsourceOpen
    def set_FGIsourceOpen(self, FGIsourceOpen): self.FGIsourceOpen = FGIsourceOpen
    def get_FGIsourceProtected(self): return self.FGIsourceProtected
    def set_FGIsourceProtected(self, FGIsourceProtected): self.FGIsourceProtected = FGIsourceProtected
    def get_SCIcontrols(self): return self.SCIcontrols
    def set_SCIcontrols(self, SCIcontrols): self.SCIcontrols = SCIcontrols
    def get_declassification(self): return self.declassification
    def set_declassification(self, declassification): self.declassification = declassification
    def get_disseminationControls(self): return self.disseminationControls
    def set_disseminationControls(self, disseminationControls): self.disseminationControls = disseminationControls
    def get_nonICmarkings(self): return self.nonICmarkings
    def set_nonICmarkings(self, nonICmarkings): self.nonICmarkings = nonICmarkings
    def get_nonUSmarkings(self): return self.nonUSmarkings
    def set_nonUSmarkings(self, nonUSmarkings): self.nonUSmarkings = nonUSmarkings
    def get_releasableTo(self): return self.releasableTo
    def set_releasableTo(self, releasableTo): self.releasableTo = releasableTo
    def validate_titleType(self, value):
        # Validate type titleType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 80:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on titleType' % {"value" : value.encode("utf-8")} )
    def validate_descriptionType(self, value):
        # Validate type descriptionType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descriptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.title is not None or
            self.description is not None or
            self.propertySet is not None or
            self.mediaSet is not None or
            self.noteSet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='object', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='object')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='object', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='object'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.externalId is not None and 'externalId' not in already_processed:
            already_processed.add('externalId')
            outfile.write(' externalId=%s' % (quote_attrib(self.externalId), ))
        if self.resolvesTo is not None and 'resolvesTo' not in already_processed:
            already_processed.add('resolvesTo')
            outfile.write(' resolvesTo=%s' % (quote_attrib(self.resolvesTo), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.baseType is not None and 'baseType' not in already_processed:
            already_processed.add('baseType')
            outfile.write(' baseType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.baseType), input_name='baseType')), ))
        if self.timeStart is not None and 'timeStart' not in already_processed:
            already_processed.add('timeStart')
            outfile.write(' timeStart="%s"' % self.gds_format_datetime(self.timeStart, input_name='timeStart'))
        if self.timeEnd is not None and 'timeEnd' not in already_processed:
            already_processed.add('timeEnd')
            outfile.write(' timeEnd="%s"' % self.gds_format_datetime(self.timeEnd, input_name='timeEnd'))
        if self.groupFlag and 'groupFlag' not in already_processed:
            already_processed.add('groupFlag')
            outfile.write(' groupFlag="%s"' % self.gds_format_boolean(self.groupFlag, input_name='groupFlag'))
        if self.classification is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            outfile.write(' classification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.classification), input_name='classification')), ))
        if self.FGIsourceOpen is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            outfile.write(' FGIsourceOpen=%s' % (quote_attrib(self.FGIsourceOpen), ))
        if self.FGIsourceProtected is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            outfile.write(' FGIsourceProtected=%s' % (quote_attrib(self.FGIsourceProtected), ))
        if self.SCIcontrols is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            outfile.write(' SCIcontrols=%s' % (quote_attrib(self.SCIcontrols), ))
        if self.declassification is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            outfile.write(' declassification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.declassification), input_name='declassification')), ))
        if self.disseminationControls is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            outfile.write(' disseminationControls=%s' % (quote_attrib(self.disseminationControls), ))
        if self.nonICmarkings is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            outfile.write(' nonICmarkings=%s' % (quote_attrib(self.nonICmarkings), ))
        if self.nonUSmarkings is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            outfile.write(' nonUSmarkings=%s' % (quote_attrib(self.nonUSmarkings), ))
        if self.releasableTo is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            outfile.write(' releasableTo=%s' % (quote_attrib(self.releasableTo), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='object', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        if self.propertySet is not None:
            self.propertySet.export(outfile, level, namespace_, name_='propertySet', pretty_print=pretty_print)
        if self.mediaSet is not None:
            self.mediaSet.export(outfile, level, namespace_, name_='mediaSet', pretty_print=pretty_print)
        if self.noteSet is not None:
            self.noteSet.export(outfile, level, namespace_, name_='noteSet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('externalId', node)
        if value is not None and 'externalId' not in already_processed:
            already_processed.add('externalId')
            self.externalId = value
        value = find_attr_value_('resolvesTo', node)
        if value is not None and 'resolvesTo' not in already_processed:
            already_processed.add('resolvesTo')
            self.resolvesTo = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('baseType', node)
        if value is not None and 'baseType' not in already_processed:
            already_processed.add('baseType')
            self.baseType = value
        value = find_attr_value_('timeStart', node)
        if value is not None and 'timeStart' not in already_processed:
            already_processed.add('timeStart')
            try:
                self.timeStart = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timeStart): %s' % exp)
        value = find_attr_value_('timeEnd', node)
        if value is not None and 'timeEnd' not in already_processed:
            already_processed.add('timeEnd')
            try:
                self.timeEnd = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timeEnd): %s' % exp)
        value = find_attr_value_('groupFlag', node)
        if value is not None and 'groupFlag' not in already_processed:
            already_processed.add('groupFlag')
            if value in ('true', '1'):
                self.groupFlag = True
            elif value in ('false', '0'):
                self.groupFlag = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('classification', node)
        if value is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            self.classification = value
            self.classification = ' '.join(self.classification.split())
        value = find_attr_value_('FGIsourceOpen', node)
        if value is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            self.FGIsourceOpen = value
        value = find_attr_value_('FGIsourceProtected', node)
        if value is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            self.FGIsourceProtected = value
        value = find_attr_value_('SCIcontrols', node)
        if value is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            self.SCIcontrols = value
        value = find_attr_value_('declassification', node)
        if value is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            self.declassification = value
        value = find_attr_value_('disseminationControls', node)
        if value is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            self.disseminationControls = value
        value = find_attr_value_('nonICmarkings', node)
        if value is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            self.nonICmarkings = value
        value = find_attr_value_('nonUSmarkings', node)
        if value is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            self.nonUSmarkings = value
        value = find_attr_value_('releasableTo', node)
        if value is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            self.releasableTo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
            # validate type titleType
            self.validate_titleType(self.title)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type descriptionType
            self.validate_descriptionType(self.description)
        elif nodeName_ == 'propertySet':
            obj_ = propertySet.factory()
            obj_.build(child_)
            self.propertySet = obj_
            obj_.original_tagname_ = 'propertySet'
        elif nodeName_ == 'mediaSet':
            obj_ = mediaSet.factory()
            obj_.build(child_)
            self.mediaSet = obj_
            obj_.original_tagname_ = 'mediaSet'
        elif nodeName_ == 'noteSet':
            obj_ = noteSet.factory()
            obj_.build(child_)
            self.noteSet = obj_
            obj_.original_tagname_ = 'noteSet'
# end class object


class noteSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, note=None):
        self.original_tagname_ = None
        if note is None:
            self.note = []
        else:
            self.note = note
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noteSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noteSet.subclass:
            return noteSet.subclass(*args_, **kwargs_)
        else:
            return noteSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note_at(self, index, value): self.note.insert(index, value)
    def replace_note_at(self, index, value): self.note[index] = value
    def hasContent_(self):
        if (
            self.note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='noteSet', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='noteSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='noteSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='noteSet'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='noteSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for note_ in self.note:
            note_.export(outfile, level, namespace_, name_='note', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'note':
            obj_ = note.factory()
            obj_.build(child_)
            self.note.append(obj_)
            obj_.original_tagname_ = 'note'
# end class noteSet


class objectSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, object=None):
        self.original_tagname_ = None
        if object is None:
            self.object = []
        else:
            self.object = object
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, objectSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if objectSet.subclass:
            return objectSet.subclass(*args_, **kwargs_)
        else:
            return objectSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def add_object(self, value): self.object.append(value)
    def insert_object_at(self, index, value): self.object.insert(index, value)
    def replace_object_at(self, index, value): self.object[index] = value
    def hasContent_(self):
        if (
            self.object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='objectSet', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='objectSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='objectSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='objectSet'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='objectSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_ in self.object:
            object_.export(outfile, level, namespace_, name_='object', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object':
            obj_ = object.factory()
            obj_.build(child_)
            self.object.append(obj_)
            obj_.original_tagname_ = 'object'
# end class objectSet


class dataSource(GeneratedsSuper):
    """The SecurityAttributes attribute group is no longer supported by
    Palantir. It remains solely for XML parsing backwards
    compatibility. Beyond that, attributes defined in the
    SecurityAttributes attribute group are ignored."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, id=None, externalId=None, isStub=None, aclId=None, classification=None, FGIsourceOpen=None, FGIsourceProtected=None, SCIcontrols=None, declassification=None, disseminationControls=None, nonICmarkings=None, nonUSmarkings=None, releasableTo=None, name=None, description=None, discoveryMessage=None, primaryObject=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.externalId = _cast(None, externalId)
        self.isStub = _cast(bool, isStub)
        self.aclId = _cast(None, aclId)
        self.classification = _cast(None, classification)
        self.FGIsourceOpen = _cast(None, FGIsourceOpen)
        self.FGIsourceProtected = _cast(None, FGIsourceProtected)
        self.SCIcontrols = _cast(None, SCIcontrols)
        self.declassification = _cast(None, declassification)
        self.disseminationControls = _cast(None, disseminationControls)
        self.nonICmarkings = _cast(None, nonICmarkings)
        self.nonUSmarkings = _cast(None, nonUSmarkings)
        self.releasableTo = _cast(None, releasableTo)
        self.name = name
        self.validate_nameType(self.name)
        self.description = description
        self.validate_descriptionType1(self.description)
        self.discoveryMessage = discoveryMessage
        self.validate_discoveryMessageType(self.discoveryMessage)
        self.primaryObject = primaryObject
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dataSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dataSource.subclass:
            return dataSource.subclass(*args_, **kwargs_)
        else:
            return dataSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_discoveryMessage(self): return self.discoveryMessage
    def set_discoveryMessage(self, discoveryMessage): self.discoveryMessage = discoveryMessage
    def get_primaryObject(self): return self.primaryObject
    def set_primaryObject(self, primaryObject): self.primaryObject = primaryObject
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_externalId(self): return self.externalId
    def set_externalId(self, externalId): self.externalId = externalId
    def get_isStub(self): return self.isStub
    def set_isStub(self, isStub): self.isStub = isStub
    def get_aclId(self): return self.aclId
    def set_aclId(self, aclId): self.aclId = aclId
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def get_FGIsourceOpen(self): return self.FGIsourceOpen
    def set_FGIsourceOpen(self, FGIsourceOpen): self.FGIsourceOpen = FGIsourceOpen
    def get_FGIsourceProtected(self): return self.FGIsourceProtected
    def set_FGIsourceProtected(self, FGIsourceProtected): self.FGIsourceProtected = FGIsourceProtected
    def get_SCIcontrols(self): return self.SCIcontrols
    def set_SCIcontrols(self, SCIcontrols): self.SCIcontrols = SCIcontrols
    def get_declassification(self): return self.declassification
    def set_declassification(self, declassification): self.declassification = declassification
    def get_disseminationControls(self): return self.disseminationControls
    def set_disseminationControls(self, disseminationControls): self.disseminationControls = disseminationControls
    def get_nonICmarkings(self): return self.nonICmarkings
    def set_nonICmarkings(self, nonICmarkings): self.nonICmarkings = nonICmarkings
    def get_nonUSmarkings(self): return self.nonUSmarkings
    def set_nonUSmarkings(self, nonUSmarkings): self.nonUSmarkings = nonUSmarkings
    def get_releasableTo(self): return self.releasableTo
    def set_releasableTo(self, releasableTo): self.releasableTo = releasableTo
    def validate_nameType(self, value):
        # Validate type nameType, a restriction on tns:nonEmptyString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 80:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nameType' % {"value" : value} )
    def validate_descriptionType1(self, value):
        # Validate type descriptionType1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 1000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descriptionType1' % {"value" : value.encode("utf-8")} )
    def validate_discoveryMessageType(self, value):
        # Validate type discoveryMessageType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on discoveryMessageType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.description is not None or
            self.discoveryMessage is not None or
            self.primaryObject is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='dataSource', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dataSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='dataSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='dataSource'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.externalId is not None and 'externalId' not in already_processed:
            already_processed.add('externalId')
            outfile.write(' externalId=%s' % (quote_attrib(self.externalId), ))
        if self.isStub is not None and 'isStub' not in already_processed:
            already_processed.add('isStub')
            outfile.write(' isStub="%s"' % self.gds_format_boolean(self.isStub, input_name='isStub'))
        if self.aclId is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            outfile.write(' aclId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aclId), input_name='aclId')), ))
        if self.classification is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            outfile.write(' classification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.classification), input_name='classification')), ))
        if self.FGIsourceOpen is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            outfile.write(' FGIsourceOpen=%s' % (quote_attrib(self.FGIsourceOpen), ))
        if self.FGIsourceProtected is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            outfile.write(' FGIsourceProtected=%s' % (quote_attrib(self.FGIsourceProtected), ))
        if self.SCIcontrols is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            outfile.write(' SCIcontrols=%s' % (quote_attrib(self.SCIcontrols), ))
        if self.declassification is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            outfile.write(' declassification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.declassification), input_name='declassification')), ))
        if self.disseminationControls is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            outfile.write(' disseminationControls=%s' % (quote_attrib(self.disseminationControls), ))
        if self.nonICmarkings is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            outfile.write(' nonICmarkings=%s' % (quote_attrib(self.nonICmarkings), ))
        if self.nonUSmarkings is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            outfile.write(' nonUSmarkings=%s' % (quote_attrib(self.nonUSmarkings), ))
        if self.releasableTo is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            outfile.write(' releasableTo=%s' % (quote_attrib(self.releasableTo), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='dataSource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        if self.discoveryMessage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscoveryMessage>%s</%sdiscoveryMessage>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.discoveryMessage), input_name='discoveryMessage')), namespace_, eol_))
        if self.primaryObject is not None:
            self.primaryObject.export(outfile, level, namespace_, name_='primaryObject', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('externalId', node)
        if value is not None and 'externalId' not in already_processed:
            already_processed.add('externalId')
            self.externalId = value
        value = find_attr_value_('isStub', node)
        if value is not None and 'isStub' not in already_processed:
            already_processed.add('isStub')
            if value in ('true', '1'):
                self.isStub = True
            elif value in ('false', '0'):
                self.isStub = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('aclId', node)
        if value is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            self.aclId = value
        value = find_attr_value_('classification', node)
        if value is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            self.classification = value
            self.classification = ' '.join(self.classification.split())
        value = find_attr_value_('FGIsourceOpen', node)
        if value is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            self.FGIsourceOpen = value
        value = find_attr_value_('FGIsourceProtected', node)
        if value is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            self.FGIsourceProtected = value
        value = find_attr_value_('SCIcontrols', node)
        if value is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            self.SCIcontrols = value
        value = find_attr_value_('declassification', node)
        if value is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            self.declassification = value
        value = find_attr_value_('disseminationControls', node)
        if value is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            self.disseminationControls = value
        value = find_attr_value_('nonICmarkings', node)
        if value is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            self.nonICmarkings = value
        value = find_attr_value_('nonUSmarkings', node)
        if value is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            self.nonUSmarkings = value
        value = find_attr_value_('releasableTo', node)
        if value is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            self.releasableTo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type nameType
            self.validate_nameType(self.name)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type descriptionType1
            self.validate_descriptionType1(self.description)
        elif nodeName_ == 'discoveryMessage':
            discoveryMessage_ = child_.text
            discoveryMessage_ = self.gds_validate_string(discoveryMessage_, node, 'discoveryMessage')
            self.discoveryMessage = discoveryMessage_
            # validate type discoveryMessageType
            self.validate_discoveryMessageType(self.discoveryMessage)
        elif nodeName_ == 'primaryObject':
            obj_ = primaryObject.factory()
            obj_.build(child_)
            self.primaryObject = obj_
            obj_.original_tagname_ = 'primaryObject'
# end class dataSource


class dataSourceSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dataSource=None):
        self.original_tagname_ = None
        if dataSource is None:
            self.dataSource = []
        else:
            self.dataSource = dataSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dataSourceSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dataSourceSet.subclass:
            return dataSourceSet.subclass(*args_, **kwargs_)
        else:
            return dataSourceSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataSource(self): return self.dataSource
    def set_dataSource(self, dataSource): self.dataSource = dataSource
    def add_dataSource(self, value): self.dataSource.append(value)
    def insert_dataSource_at(self, index, value): self.dataSource.insert(index, value)
    def replace_dataSource_at(self, index, value): self.dataSource[index] = value
    def hasContent_(self):
        if (
            self.dataSource
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='dataSourceSet', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dataSourceSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='dataSourceSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='dataSourceSet'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='dataSourceSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dataSource_ in self.dataSource:
            dataSource_.export(outfile, level, namespace_, name_='dataSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dataSource':
            obj_ = dataSource.factory()
            obj_.build(child_)
            self.dataSource.append(obj_)
            obj_.original_tagname_ = 'dataSource'
# end class dataSourceSet


class link(GeneratedsSuper):
    """The SecurityAttributes attribute group is no longer supported by
    Palantir. It remains solely for XML parsing backwards
    compatibility. Beyond that, attributes defined in the
    SecurityAttributes attribute group are ignored."""
    subclass = None
    superclass = None
    def __init__(self, parentRef=None, childRef=None, type_=None, role=None, id=None, aclId=None, classification=None, FGIsourceOpen=None, FGIsourceProtected=None, SCIcontrols=None, declassification=None, disseminationControls=None, nonICmarkings=None, nonUSmarkings=None, releasableTo=None, text=None, timestamp=None, timeInterval=None, dataSourceRecordSet=None):
        self.original_tagname_ = None
        self.parentRef = _cast(None, parentRef)
        self.childRef = _cast(None, childRef)
        self.type_ = _cast(None, type_)
        self.role = _cast(None, role)
        self.id = _cast(None, id)
        self.aclId = _cast(None, aclId)
        self.classification = _cast(None, classification)
        self.FGIsourceOpen = _cast(None, FGIsourceOpen)
        self.FGIsourceProtected = _cast(None, FGIsourceProtected)
        self.SCIcontrols = _cast(None, SCIcontrols)
        self.declassification = _cast(None, declassification)
        self.disseminationControls = _cast(None, disseminationControls)
        self.nonICmarkings = _cast(None, nonICmarkings)
        self.nonUSmarkings = _cast(None, nonUSmarkings)
        self.releasableTo = _cast(None, releasableTo)
        self.text = text
        self.timestamp = timestamp
        self.timeInterval = timeInterval
        self.dataSourceRecordSet = dataSourceRecordSet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, link)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if link.subclass:
            return link.subclass(*args_, **kwargs_)
        else:
            return link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_timeInterval(self): return self.timeInterval
    def set_timeInterval(self, timeInterval): self.timeInterval = timeInterval
    def get_dataSourceRecordSet(self): return self.dataSourceRecordSet
    def set_dataSourceRecordSet(self, dataSourceRecordSet): self.dataSourceRecordSet = dataSourceRecordSet
    def get_parentRef(self): return self.parentRef
    def set_parentRef(self, parentRef): self.parentRef = parentRef
    def get_childRef(self): return self.childRef
    def set_childRef(self, childRef): self.childRef = childRef
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_aclId(self): return self.aclId
    def set_aclId(self, aclId): self.aclId = aclId
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def get_FGIsourceOpen(self): return self.FGIsourceOpen
    def set_FGIsourceOpen(self, FGIsourceOpen): self.FGIsourceOpen = FGIsourceOpen
    def get_FGIsourceProtected(self): return self.FGIsourceProtected
    def set_FGIsourceProtected(self, FGIsourceProtected): self.FGIsourceProtected = FGIsourceProtected
    def get_SCIcontrols(self): return self.SCIcontrols
    def set_SCIcontrols(self, SCIcontrols): self.SCIcontrols = SCIcontrols
    def get_declassification(self): return self.declassification
    def set_declassification(self, declassification): self.declassification = declassification
    def get_disseminationControls(self): return self.disseminationControls
    def set_disseminationControls(self, disseminationControls): self.disseminationControls = disseminationControls
    def get_nonICmarkings(self): return self.nonICmarkings
    def set_nonICmarkings(self, nonICmarkings): self.nonICmarkings = nonICmarkings
    def get_nonUSmarkings(self): return self.nonUSmarkings
    def set_nonUSmarkings(self, nonUSmarkings): self.nonUSmarkings = nonUSmarkings
    def get_releasableTo(self): return self.releasableTo
    def set_releasableTo(self, releasableTo): self.releasableTo = releasableTo
    def hasContent_(self):
        if (
            self.text is not None or
            self.timestamp is not None or
            self.timeInterval is not None or
            self.dataSourceRecordSet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='link', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='link')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='link', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='link'):
        if self.parentRef is not None and 'parentRef' not in already_processed:
            already_processed.add('parentRef')
            outfile.write(' parentRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentRef), input_name='parentRef')), ))
        if self.childRef is not None and 'childRef' not in already_processed:
            already_processed.add('childRef')
            outfile.write(' childRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.childRef), input_name='childRef')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.role), input_name='role')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.aclId is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            outfile.write(' aclId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aclId), input_name='aclId')), ))
        if self.classification is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            outfile.write(' classification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.classification), input_name='classification')), ))
        if self.FGIsourceOpen is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            outfile.write(' FGIsourceOpen=%s' % (quote_attrib(self.FGIsourceOpen), ))
        if self.FGIsourceProtected is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            outfile.write(' FGIsourceProtected=%s' % (quote_attrib(self.FGIsourceProtected), ))
        if self.SCIcontrols is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            outfile.write(' SCIcontrols=%s' % (quote_attrib(self.SCIcontrols), ))
        if self.declassification is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            outfile.write(' declassification=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.declassification), input_name='declassification')), ))
        if self.disseminationControls is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            outfile.write(' disseminationControls=%s' % (quote_attrib(self.disseminationControls), ))
        if self.nonICmarkings is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            outfile.write(' nonICmarkings=%s' % (quote_attrib(self.nonICmarkings), ))
        if self.nonUSmarkings is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            outfile.write(' nonUSmarkings=%s' % (quote_attrib(self.nonUSmarkings), ))
        if self.releasableTo is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            outfile.write(' releasableTo=%s' % (quote_attrib(self.releasableTo), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='link', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.text is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stext>%s</%stext>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.text), input_name='text')), namespace_, eol_))
        if self.timestamp is not None:
            self.timestamp.export(outfile, level, namespace_, name_='timestamp', pretty_print=pretty_print)
        if self.timeInterval is not None:
            self.timeInterval.export(outfile, level, namespace_, name_='timeInterval', pretty_print=pretty_print)
        if self.dataSourceRecordSet is not None:
            self.dataSourceRecordSet.export(outfile, level, namespace_, name_='dataSourceRecordSet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parentRef', node)
        if value is not None and 'parentRef' not in already_processed:
            already_processed.add('parentRef')
            self.parentRef = value
        value = find_attr_value_('childRef', node)
        if value is not None and 'childRef' not in already_processed:
            already_processed.add('childRef')
            self.childRef = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('aclId', node)
        if value is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            self.aclId = value
        value = find_attr_value_('classification', node)
        if value is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            self.classification = value
            self.classification = ' '.join(self.classification.split())
        value = find_attr_value_('FGIsourceOpen', node)
        if value is not None and 'FGIsourceOpen' not in already_processed:
            already_processed.add('FGIsourceOpen')
            self.FGIsourceOpen = value
        value = find_attr_value_('FGIsourceProtected', node)
        if value is not None and 'FGIsourceProtected' not in already_processed:
            already_processed.add('FGIsourceProtected')
            self.FGIsourceProtected = value
        value = find_attr_value_('SCIcontrols', node)
        if value is not None and 'SCIcontrols' not in already_processed:
            already_processed.add('SCIcontrols')
            self.SCIcontrols = value
        value = find_attr_value_('declassification', node)
        if value is not None and 'declassification' not in already_processed:
            already_processed.add('declassification')
            self.declassification = value
        value = find_attr_value_('disseminationControls', node)
        if value is not None and 'disseminationControls' not in already_processed:
            already_processed.add('disseminationControls')
            self.disseminationControls = value
        value = find_attr_value_('nonICmarkings', node)
        if value is not None and 'nonICmarkings' not in already_processed:
            already_processed.add('nonICmarkings')
            self.nonICmarkings = value
        value = find_attr_value_('nonUSmarkings', node)
        if value is not None and 'nonUSmarkings' not in already_processed:
            already_processed.add('nonUSmarkings')
            self.nonUSmarkings = value
        value = find_attr_value_('releasableTo', node)
        if value is not None and 'releasableTo' not in already_processed:
            already_processed.add('releasableTo')
            self.releasableTo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'text':
            text_ = child_.text
            text_ = self.gds_validate_string(text_, node, 'text')
            self.text = text_
        elif nodeName_ == 'timestamp':
            obj_ = timestamp.factory()
            obj_.build(child_)
            self.timestamp = obj_
            obj_.original_tagname_ = 'timestamp'
        elif nodeName_ == 'timeInterval':
            obj_ = timeInterval.factory()
            obj_.build(child_)
            self.timeInterval = obj_
            obj_.original_tagname_ = 'timeInterval'
        elif nodeName_ == 'dataSourceRecordSet':
            obj_ = dataSourceRecordSet.factory()
            obj_.build(child_)
            self.dataSourceRecordSet = obj_
            obj_.original_tagname_ = 'dataSourceRecordSet'
# end class link


class linkSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, link=None):
        self.original_tagname_ = None
        if link is None:
            self.link = []
        else:
            self.link = link
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, linkSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if linkSet.subclass:
            return linkSet.subclass(*args_, **kwargs_)
        else:
            return linkSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def add_link(self, value): self.link.append(value)
    def insert_link_at(self, index, value): self.link.insert(index, value)
    def replace_link_at(self, index, value): self.link[index] = value
    def hasContent_(self):
        if (
            self.link
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='linkSet', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='linkSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='linkSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='linkSet'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='linkSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for link_ in self.link:
            link_.export(outfile, level, namespace_, name_='link', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'link':
            obj_ = link.factory()
            obj_.build(child_)
            self.link.append(obj_)
            obj_.original_tagname_ = 'link'
# end class linkSet


class graph(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, aclSet=None, dataSourceSet=None, objectSet=None, linkSet=None):
        self.original_tagname_ = None
        self.aclSet = aclSet
        self.dataSourceSet = dataSourceSet
        self.objectSet = objectSet
        self.linkSet = linkSet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, graph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if graph.subclass:
            return graph.subclass(*args_, **kwargs_)
        else:
            return graph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aclSet(self): return self.aclSet
    def set_aclSet(self, aclSet): self.aclSet = aclSet
    def get_dataSourceSet(self): return self.dataSourceSet
    def set_dataSourceSet(self, dataSourceSet): self.dataSourceSet = dataSourceSet
    def get_objectSet(self): return self.objectSet
    def set_objectSet(self, objectSet): self.objectSet = objectSet
    def get_linkSet(self): return self.linkSet
    def set_linkSet(self, linkSet): self.linkSet = linkSet
    def hasContent_(self):
        if (
            self.aclSet is not None or
            self.dataSourceSet is not None or
            self.objectSet is not None or
            self.linkSet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='graph', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='graph')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='graph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='graph'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='graph', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.aclSet is not None:
            self.aclSet.export(outfile, level, namespace_, name_='aclSet', pretty_print=pretty_print)
        if self.dataSourceSet is not None:
            self.dataSourceSet.export(outfile, level, namespace_, name_='dataSourceSet', pretty_print=pretty_print)
        if self.objectSet is not None:
            self.objectSet.export(outfile, level, namespace_, name_='objectSet', pretty_print=pretty_print)
        if self.linkSet is not None:
            self.linkSet.export(outfile, level, namespace_, name_='linkSet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'aclSet':
            obj_ = aclSet.factory()
            obj_.build(child_)
            self.aclSet = obj_
            obj_.original_tagname_ = 'aclSet'
        elif nodeName_ == 'dataSourceSet':
            obj_ = dataSourceSet.factory()
            obj_.build(child_)
            self.dataSourceSet = obj_
            obj_.original_tagname_ = 'dataSourceSet'
        elif nodeName_ == 'objectSet':
            obj_ = objectSet.factory()
            obj_.build(child_)
            self.objectSet = obj_
            obj_.original_tagname_ = 'objectSet'
        elif nodeName_ == 'linkSet':
            obj_ = linkSet.factory()
            obj_.build(child_)
            self.linkSet = obj_
            obj_.original_tagname_ = 'linkSet'
# end class graph


class palantir(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, systemId=None, graph=None):
        self.original_tagname_ = None
        self.systemId = _cast(int, systemId)
        self.graph = graph
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, palantir)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if palantir.subclass:
            return palantir.subclass(*args_, **kwargs_)
        else:
            return palantir(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_graph(self): return self.graph
    def set_graph(self, graph): self.graph = graph
    def get_systemId(self): return self.systemId
    def set_systemId(self, systemId): self.systemId = systemId
    def hasContent_(self):
        if (
            self.graph is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='palantir', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='palantir')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='palantir', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='palantir'):
        if self.systemId is not None and 'systemId' not in already_processed:
            already_processed.add('systemId')
            outfile.write(' systemId="%s"' % self.gds_format_integer(self.systemId, input_name='systemId'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='palantir', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.graph is not None:
            self.graph.export(outfile, level, namespace_, name_='graph', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('systemId', node)
        if value is not None and 'systemId' not in already_processed:
            already_processed.add('systemId')
            try:
                self.systemId = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'graph':
            obj_ = graph.factory()
            obj_.build(child_)
            self.graph = obj_
            obj_.original_tagname_ = 'graph'
# end class palantir


class primaryObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, objectRef=None):
        self.original_tagname_ = None
        self.objectRef = _cast(None, objectRef)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, primaryObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if primaryObject.subclass:
            return primaryObject.subclass(*args_, **kwargs_)
        else:
            return primaryObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_objectRef(self): return self.objectRef
    def set_objectRef(self, objectRef): self.objectRef = objectRef
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='primaryObject', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='primaryObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='primaryObject', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='primaryObject'):
        if self.objectRef is not None and 'objectRef' not in already_processed:
            already_processed.add('objectRef')
            outfile.write(' objectRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.objectRef), input_name='objectRef')), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='primaryObject', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('objectRef', node)
        if value is not None and 'objectRef' not in already_processed:
            already_processed.add('objectRef')
            self.objectRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class primaryObject


class propertyRawValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyRawValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyRawValue.subclass:
            return propertyRawValue.subclass(*args_, **kwargs_)
        else:
            return propertyRawValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='propertyRawValue', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyRawValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='propertyRawValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='propertyRawValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='propertyRawValue', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyRawValue


class propertyUnparsedValue(GeneratedsSuper):
    """This element allows us to capture unparsed property data, as opposed
    to raw values. Raw values are put through Property Makers to
    build Properties. Unparsed data is just assembled as-is into
    unparsed properties."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyUnparsedValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyUnparsedValue.subclass:
            return propertyUnparsedValue.subclass(*args_, **kwargs_)
        else:
            return propertyUnparsedValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='propertyUnparsedValue', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyUnparsedValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else self.gds_encode(str(self.valueOf_))))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='propertyUnparsedValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='propertyUnparsedValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='propertyUnparsedValue', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyUnparsedValue


class propertyTimeInterval(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, timeStart=None, timeEnd=None):
        self.original_tagname_ = None
        if isinstance(timeStart, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timeStart, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timeStart
        self.timeStart = initvalue_
        if isinstance(timeEnd, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timeEnd, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timeEnd
        self.timeEnd = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyTimeInterval)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyTimeInterval.subclass:
            return propertyTimeInterval.subclass(*args_, **kwargs_)
        else:
            return propertyTimeInterval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timeStart(self): return self.timeStart
    def set_timeStart(self, timeStart): self.timeStart = timeStart
    def get_timeEnd(self): return self.timeEnd
    def set_timeEnd(self, timeEnd): self.timeEnd = timeEnd
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='propertyTimeInterval', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyTimeInterval')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='propertyTimeInterval', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='propertyTimeInterval'):
        if self.timeStart is not None and 'timeStart' not in already_processed:
            already_processed.add('timeStart')
            outfile.write(' timeStart="%s"' % self.gds_format_datetime(self.timeStart, input_name='timeStart'))
        if self.timeEnd is not None and 'timeEnd' not in already_processed:
            already_processed.add('timeEnd')
            outfile.write(' timeEnd="%s"' % self.gds_format_datetime(self.timeEnd, input_name='timeEnd'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='propertyTimeInterval', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timeStart', node)
        if value is not None and 'timeStart' not in already_processed:
            already_processed.add('timeStart')
            try:
                self.timeStart = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timeStart): %s' % exp)
        value = find_attr_value_('timeEnd', node)
        if value is not None and 'timeEnd' not in already_processed:
            already_processed.add('timeEnd')
            try:
                self.timeEnd = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timeEnd): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyTimeInterval


class aclSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, defaultAcl=None, acl=None):
        self.original_tagname_ = None
        self.defaultAcl = defaultAcl
        if acl is None:
            self.acl = []
        else:
            self.acl = acl
        if acl is None:
            self.acl = []
        else:
            self.acl = acl
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, aclSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if aclSet.subclass:
            return aclSet.subclass(*args_, **kwargs_)
        else:
            return aclSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_defaultAcl(self): return self.defaultAcl
    def set_defaultAcl(self, defaultAcl): self.defaultAcl = defaultAcl
    def get_acl(self): return self.acl
    def set_acl(self, acl): self.acl = acl
    def add_acl(self, value): self.acl.append(value)
    def insert_acl_at(self, index, value): self.acl.insert(index, value)
    def replace_acl_at(self, index, value): self.acl[index] = value
    def get_acl(self): return self.acl
    def set_acl(self, acl): self.acl = acl
    def add_acl(self, value): self.acl.append(value)
    def insert_acl_at(self, index, value): self.acl.insert(index, value)
    def replace_acl_at(self, index, value): self.acl[index] = value
    def hasContent_(self):
        if (
            self.defaultAcl is not None or
            self.acl or
            self.acl
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='aclSet', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aclSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='aclSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='aclSet'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='aclSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.defaultAcl is not None:
            self.defaultAcl.export(outfile, level, namespace_, name_='defaultAcl', pretty_print=pretty_print)
        for acl_ in self.acl:
            acl_.export(outfile, level, namespace_, name_='acl', pretty_print=pretty_print)
        for acl_ in self.acl:
            acl_.export(outfile, level, namespace_, name_='acl', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'defaultAcl':
            obj_ = acl.factory()
            obj_.build(child_)
            self.defaultAcl = obj_
            obj_.original_tagname_ = 'defaultAcl'
        elif nodeName_ == 'acl':
            obj_ = acl.factory()
            obj_.build(child_)
            self.acl.append(obj_)
            obj_.original_tagname_ = 'acl'
        elif nodeName_ == 'acl':
            obj_ = acl.factory()
            obj_.build(child_)
            self.acl.append(obj_)
            obj_.original_tagname_ = 'acl'
# end class aclSet


class acl(GeneratedsSuper):
    """The acl domain identifies a group of systems that share the same
    security model. Acls from domains other than your own system's
    domain can be transformed during import. Acls with the domain
    '__LOCAL_ACL' or '' are treated the same as acls local to the
    importing system."""
    subclass = None
    superclass = None
    def __init__(self, aclId=None, aclDomain=None, aclReference=None, aclSpecification=None):
        self.original_tagname_ = None
        self.aclId = _cast(None, aclId)
        self.aclDomain = _cast(None, aclDomain)
        self.aclReference = aclReference
        if aclSpecification is None:
            self.aclSpecification = []
        else:
            self.aclSpecification = aclSpecification
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, acl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if acl.subclass:
            return acl.subclass(*args_, **kwargs_)
        else:
            return acl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aclReference(self): return self.aclReference
    def set_aclReference(self, aclReference): self.aclReference = aclReference
    def get_aclSpecification(self): return self.aclSpecification
    def set_aclSpecification(self, aclSpecification): self.aclSpecification = aclSpecification
    def add_aclSpecification(self, value): self.aclSpecification.append(value)
    def insert_aclSpecification_at(self, index, value): self.aclSpecification.insert(index, value)
    def replace_aclSpecification_at(self, index, value): self.aclSpecification[index] = value
    def get_aclId(self): return self.aclId
    def set_aclId(self, aclId): self.aclId = aclId
    def get_aclDomain(self): return self.aclDomain
    def set_aclDomain(self, aclDomain): self.aclDomain = aclDomain
    def hasContent_(self):
        if (
            self.aclReference is not None or
            self.aclSpecification
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='acl', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='acl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='acl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='acl'):
        if self.aclId is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            outfile.write(' aclId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aclId), input_name='aclId')), ))
        if self.aclDomain is not None and 'aclDomain' not in already_processed:
            already_processed.add('aclDomain')
            outfile.write(' aclDomain=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aclDomain), input_name='aclDomain')), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='acl', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.aclReference is not None:
            self.aclReference.export(outfile, level, namespace_, name_='aclReference', pretty_print=pretty_print)
        for aclSpecification_ in self.aclSpecification:
            aclSpecification_.export(outfile, level, namespace_, name_='aclSpecification', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aclId', node)
        if value is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            self.aclId = value
        value = find_attr_value_('aclDomain', node)
        if value is not None and 'aclDomain' not in already_processed:
            already_processed.add('aclDomain')
            self.aclDomain = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'aclReference':
            obj_ = aclReference.factory()
            obj_.build(child_)
            self.aclReference = obj_
            obj_.original_tagname_ = 'aclReference'
        elif nodeName_ == 'aclSpecification':
            obj_ = aclSpecification.factory()
            obj_.build(child_)
            self.aclSpecification.append(obj_)
            obj_.original_tagname_ = 'aclSpecification'
# end class acl


class aclReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, aclId=None):
        self.original_tagname_ = None
        self.aclId = _cast(int, aclId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, aclReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if aclReference.subclass:
            return aclReference.subclass(*args_, **kwargs_)
        else:
            return aclReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aclId(self): return self.aclId
    def set_aclId(self, aclId): self.aclId = aclId
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='aclReference', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aclReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='aclReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='aclReference'):
        if self.aclId is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            outfile.write(' aclId="%s"' % self.gds_format_integer(self.aclId, input_name='aclId'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='aclReference', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aclId', node)
        if value is not None and 'aclId' not in already_processed:
            already_processed.add('aclId')
            try:
                self.aclId = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class aclReference


class aclSpecification(GeneratedsSuper):
    """For backwards compatibility, the type attribute isn't required. If
    it isn't specified, as indicated by its associated default, the
    assumed value is 'group'. 'user' is no longer a valid value for
    the type attribute. When the Palantir XML parser encounters this
    value, it logs a warning, and instead treats the type attribute
    as if its associated value is 'group'. While, from the
    perspective of XML validation, setting the type attribute to
    'user' is OK, given the interpretation of 'user' as 'group',
    please note that doing so may lead to unexpected errors. If
    authSourceTag is not specified, we attempt to locate the
    externalId over all authentication sources. The system expects
    to match only one authentication source in this case and fails
    if it finds 0 or multiple sources with a match. Please note
    that, if specified, authSourceTag is ignored if type is set to
    'classification'. The ID associated with the entity referenced
    by the aclSpecification. For example, if type is set to 'group'
    and authSourceTag references an LDAP authentication source, the
    value associated with the externalId attribute might be either a
    DN or an object GUID. If type is set to 'classification', the
    Palantir XML parser interprets the value associated with the
    externalId attribute as a classification string. The permissions
    attribute isn't required because the permissions associated with
    classifications are implied (always write). Note, however, that
    if type is set to 'group', the Palantir XML parser will raise an
    error if the permissions attribute isn't specified. If the type
    is set to 'classification' and the permissions attribute is
    specified, the Palantir XML parser will log an appropriate
    warning and ignore the specified permissions."""
    subclass = None
    superclass = None
    def __init__(self, type_='group', authSourceTag=None, externalId=None, permissions=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.authSourceTag = _cast(None, authSourceTag)
        self.externalId = _cast(None, externalId)
        self.permissions = _cast(None, permissions)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, aclSpecification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if aclSpecification.subclass:
            return aclSpecification.subclass(*args_, **kwargs_)
        else:
            return aclSpecification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_authSourceTag(self): return self.authSourceTag
    def set_authSourceTag(self, authSourceTag): self.authSourceTag = authSourceTag
    def get_externalId(self): return self.externalId
    def set_externalId(self, externalId): self.externalId = externalId
    def get_permissions(self): return self.permissions
    def set_permissions(self, permissions): self.permissions = permissions
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='aclSpecification', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aclSpecification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='aclSpecification', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='aclSpecification'):
        if self.type_ != "group" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.authSourceTag is not None and 'authSourceTag' not in already_processed:
            already_processed.add('authSourceTag')
            outfile.write(' authSourceTag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authSourceTag), input_name='authSourceTag')), ))
        if self.externalId is not None and 'externalId' not in already_processed:
            already_processed.add('externalId')
            outfile.write(' externalId=%s' % (quote_attrib(self.externalId), ))
        if self.permissions is not None and 'permissions' not in already_processed:
            already_processed.add('permissions')
            outfile.write(' permissions=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.permissions), input_name='permissions')), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='aclSpecification', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('authSourceTag', node)
        if value is not None and 'authSourceTag' not in already_processed:
            already_processed.add('authSourceTag')
            self.authSourceTag = value
        value = find_attr_value_('externalId', node)
        if value is not None and 'externalId' not in already_processed:
            already_processed.add('externalId')
            self.externalId = value
        value = find_attr_value_('permissions', node)
        if value is not None and 'permissions' not in already_processed:
            already_processed.add('permissions')
            self.permissions = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class aclSpecification


class gisData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, point=None, geo_data=None):
        self.original_tagname_ = None
        self.point = point
        self.geo_data = geo_data
        self.validate_geo_data(self.geo_data)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gisData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gisData.subclass:
            return gisData.subclass(*args_, **kwargs_)
        else:
            return gisData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_point(self): return self.point
    def set_point(self, point): self.point = point
    def get_geo_data(self): return self.geo_data
    def set_geo_data(self, geo_data): self.geo_data = geo_data
    def validate_geo_data(self, value):
        # Validate type geo_data, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.point is not None or
            self.geo_data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='gisData', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gisData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='gisData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='gisData'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='gisData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.point is not None:
            self.point.export(outfile, level, namespace_, name_='point', pretty_print=pretty_print)
        if self.geo_data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgeo_data>%s</%sgeo_data>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.geo_data), input_name='geo_data')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'point':
            obj_ = point.factory()
            obj_.build(child_)
            self.point = obj_
            obj_.original_tagname_ = 'point'
        elif nodeName_ == 'geo_data':
            geo_data_ = child_.text
            geo_data_ = self.gds_validate_string(geo_data_, node, 'geo_data')
            self.geo_data = geo_data_
            # validate type geo_data
            self.validate_geo_data(self.geo_data)
# end class gisData


class point(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, latitude=None, longitude=None, elevation=None, userLatLong=None, userUTM=None, userMGRS=None, userElevation=None):
        self.original_tagname_ = None
        self.latitude = _cast(float, latitude)
        self.longitude = _cast(float, longitude)
        self.elevation = _cast(float, elevation)
        self.userLatLong = userLatLong
        self.userUTM = userUTM
        self.userMGRS = userMGRS
        self.userElevation = userElevation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, point)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if point.subclass:
            return point.subclass(*args_, **kwargs_)
        else:
            return point(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_userLatLong(self): return self.userLatLong
    def set_userLatLong(self, userLatLong): self.userLatLong = userLatLong
    def get_userUTM(self): return self.userUTM
    def set_userUTM(self, userUTM): self.userUTM = userUTM
    def get_userMGRS(self): return self.userMGRS
    def set_userMGRS(self, userMGRS): self.userMGRS = userMGRS
    def get_userElevation(self): return self.userElevation
    def set_userElevation(self, userElevation): self.userElevation = userElevation
    def get_latitude(self): return self.latitude
    def set_latitude(self, latitude): self.latitude = latitude
    def get_longitude(self): return self.longitude
    def set_longitude(self, longitude): self.longitude = longitude
    def get_elevation(self): return self.elevation
    def set_elevation(self, elevation): self.elevation = elevation
    def hasContent_(self):
        if (
            self.userLatLong is not None or
            self.userUTM is not None or
            self.userMGRS is not None or
            self.userElevation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='point', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='point')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='point', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='point'):
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            outfile.write(' latitude="%s"' % self.gds_format_double(self.latitude, input_name='latitude'))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            outfile.write(' longitude="%s"' % self.gds_format_double(self.longitude, input_name='longitude'))
        if self.elevation is not None and 'elevation' not in already_processed:
            already_processed.add('elevation')
            outfile.write(' elevation="%s"' % self.gds_format_double(self.elevation, input_name='elevation'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='point', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.userLatLong is not None:
            self.userLatLong.export(outfile, level, namespace_, name_='userLatLong', pretty_print=pretty_print)
        if self.userUTM is not None:
            self.userUTM.export(outfile, level, namespace_, name_='userUTM', pretty_print=pretty_print)
        if self.userMGRS is not None:
            self.userMGRS.export(outfile, level, namespace_, name_='userMGRS', pretty_print=pretty_print)
        if self.userElevation is not None:
            self.userElevation.export(outfile, level, namespace_, name_='userElevation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('latitude', node)
        if value is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            try:
                self.latitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (latitude): %s' % exp)
        value = find_attr_value_('longitude', node)
        if value is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            try:
                self.longitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (longitude): %s' % exp)
        value = find_attr_value_('elevation', node)
        if value is not None and 'elevation' not in already_processed:
            already_processed.add('elevation')
            try:
                self.elevation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (elevation): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'userLatLong':
            obj_ = userLatLong.factory()
            obj_.build(child_)
            self.userLatLong = obj_
            obj_.original_tagname_ = 'userLatLong'
        elif nodeName_ == 'userUTM':
            obj_ = userUTM.factory()
            obj_.build(child_)
            self.userUTM = obj_
            obj_.original_tagname_ = 'userUTM'
        elif nodeName_ == 'userMGRS':
            obj_ = userMGRS.factory()
            obj_.build(child_)
            self.userMGRS = obj_
            obj_.original_tagname_ = 'userMGRS'
        elif nodeName_ == 'userElevation':
            obj_ = userElevation.factory()
            obj_.build(child_)
            self.userElevation = obj_
            obj_.original_tagname_ = 'userElevation'
# end class point


class userLatLong(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, latitude=None, longitude=None):
        self.original_tagname_ = None
        self.latitude = _cast(None, latitude)
        self.longitude = _cast(None, longitude)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, userLatLong)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if userLatLong.subclass:
            return userLatLong.subclass(*args_, **kwargs_)
        else:
            return userLatLong(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_latitude(self): return self.latitude
    def set_latitude(self, latitude): self.latitude = latitude
    def get_longitude(self): return self.longitude
    def set_longitude(self, longitude): self.longitude = longitude
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='userLatLong', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='userLatLong')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='userLatLong', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='userLatLong'):
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            outfile.write(' latitude=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.latitude), input_name='latitude')), ))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            outfile.write(' longitude=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.longitude), input_name='longitude')), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='userLatLong', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('latitude', node)
        if value is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            self.latitude = value
        value = find_attr_value_('longitude', node)
        if value is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            self.longitude = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class userLatLong


class userElevation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, elevation=None):
        self.original_tagname_ = None
        self.elevation = _cast(None, elevation)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, userElevation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if userElevation.subclass:
            return userElevation.subclass(*args_, **kwargs_)
        else:
            return userElevation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_elevation(self): return self.elevation
    def set_elevation(self, elevation): self.elevation = elevation
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='userElevation', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='userElevation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='userElevation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='userElevation'):
        if self.elevation is not None and 'elevation' not in already_processed:
            already_processed.add('elevation')
            outfile.write(' elevation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elevation), input_name='elevation')), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='userElevation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('elevation', node)
        if value is not None and 'elevation' not in already_processed:
            already_processed.add('elevation')
            self.elevation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class userElevation


class userUTM(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, utmZone=None, utmNorthing=None, utmEasting=None):
        self.original_tagname_ = None
        self.utmZone = _cast(None, utmZone)
        self.utmNorthing = _cast(None, utmNorthing)
        self.utmEasting = _cast(None, utmEasting)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, userUTM)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if userUTM.subclass:
            return userUTM.subclass(*args_, **kwargs_)
        else:
            return userUTM(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_utmZone(self): return self.utmZone
    def set_utmZone(self, utmZone): self.utmZone = utmZone
    def get_utmNorthing(self): return self.utmNorthing
    def set_utmNorthing(self, utmNorthing): self.utmNorthing = utmNorthing
    def get_utmEasting(self): return self.utmEasting
    def set_utmEasting(self, utmEasting): self.utmEasting = utmEasting
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='userUTM', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='userUTM')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='userUTM', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='userUTM'):
        if self.utmZone is not None and 'utmZone' not in already_processed:
            already_processed.add('utmZone')
            outfile.write(' utmZone=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.utmZone), input_name='utmZone')), ))
        if self.utmNorthing is not None and 'utmNorthing' not in already_processed:
            already_processed.add('utmNorthing')
            outfile.write(' utmNorthing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.utmNorthing), input_name='utmNorthing')), ))
        if self.utmEasting is not None and 'utmEasting' not in already_processed:
            already_processed.add('utmEasting')
            outfile.write(' utmEasting=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.utmEasting), input_name='utmEasting')), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='userUTM', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('utmZone', node)
        if value is not None and 'utmZone' not in already_processed:
            already_processed.add('utmZone')
            self.utmZone = value
        value = find_attr_value_('utmNorthing', node)
        if value is not None and 'utmNorthing' not in already_processed:
            already_processed.add('utmNorthing')
            self.utmNorthing = value
        value = find_attr_value_('utmEasting', node)
        if value is not None and 'utmEasting' not in already_processed:
            already_processed.add('utmEasting')
            self.utmEasting = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class userUTM


class userMGRS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mgrs=None):
        self.original_tagname_ = None
        self.mgrs = _cast(None, mgrs)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, userMGRS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if userMGRS.subclass:
            return userMGRS.subclass(*args_, **kwargs_)
        else:
            return userMGRS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mgrs(self): return self.mgrs
    def set_mgrs(self, mgrs): self.mgrs = mgrs
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='userMGRS', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='userMGRS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='userMGRS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='userMGRS'):
        if self.mgrs is not None and 'mgrs' not in already_processed:
            already_processed.add('mgrs')
            outfile.write(' mgrs=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mgrs), input_name='mgrs')), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='userMGRS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mgrs', node)
        if value is not None and 'mgrs' not in already_processed:
            already_processed.add('mgrs')
            self.mgrs = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class userMGRS


class timeInterval(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, timeStart=None, timeEnd=None):
        self.original_tagname_ = None
        if isinstance(timeStart, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timeStart, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timeStart
        self.timeStart = initvalue_
        if isinstance(timeEnd, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timeEnd, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timeEnd
        self.timeEnd = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, timeInterval)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if timeInterval.subclass:
            return timeInterval.subclass(*args_, **kwargs_)
        else:
            return timeInterval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timeStart(self): return self.timeStart
    def set_timeStart(self, timeStart): self.timeStart = timeStart
    def get_timeEnd(self): return self.timeEnd
    def set_timeEnd(self, timeEnd): self.timeEnd = timeEnd
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='timeInterval', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='timeInterval')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='timeInterval', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='timeInterval'):
        if self.timeStart is not None and 'timeStart' not in already_processed:
            already_processed.add('timeStart')
            outfile.write(' timeStart="%s"' % self.gds_format_datetime(self.timeStart, input_name='timeStart'))
        if self.timeEnd is not None and 'timeEnd' not in already_processed:
            already_processed.add('timeEnd')
            outfile.write(' timeEnd="%s"' % self.gds_format_datetime(self.timeEnd, input_name='timeEnd'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='timeInterval', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timeStart', node)
        if value is not None and 'timeStart' not in already_processed:
            already_processed.add('timeStart')
            try:
                self.timeStart = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timeStart): %s' % exp)
        value = find_attr_value_('timeEnd', node)
        if value is not None and 'timeEnd' not in already_processed:
            already_processed.add('timeEnd')
            try:
                self.timeEnd = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timeEnd): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class timeInterval


class timestamp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, timestamp_member=None):
        self.original_tagname_ = None
        if isinstance(timestamp_member, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timestamp_member, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timestamp_member
        self.timestamp = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, timestamp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if timestamp.subclass:
            return timestamp.subclass(*args_, **kwargs_)
        else:
            return timestamp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='timestamp', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='timestamp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='timestamp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='timestamp'):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp="%s"' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='timestamp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            try:
                self.timestamp = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timestamp): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class timestamp


class thumbnailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mimeType=None, thumbnailData=None):
        self.original_tagname_ = None
        self.mimeType = _cast(None, mimeType)
        self.thumbnailData = thumbnailData
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, thumbnailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if thumbnailType.subclass:
            return thumbnailType.subclass(*args_, **kwargs_)
        else:
            return thumbnailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_thumbnailData(self): return self.thumbnailData
    def set_thumbnailData(self, thumbnailData): self.thumbnailData = thumbnailData
    def get_mimeType(self): return self.mimeType
    def set_mimeType(self, mimeType): self.mimeType = mimeType
    def hasContent_(self):
        if (
            self.thumbnailData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='tns:', name_='thumbnailType', namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='thumbnailType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='tns:', name_='thumbnailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='thumbnailType'):
        if self.mimeType is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            outfile.write(' mimeType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mimeType), input_name='mimeType')), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='thumbnailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.thumbnailData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sthumbnailData>%s</%sthumbnailData>%s' % (namespace_, self.gds_format_base64(self.thumbnailData, input_name='thumbnailData'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mimeType', node)
        if value is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            self.mimeType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'thumbnailData':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'thumbnailData')
            else:
                bval_ = None
            self.thumbnailData = bval_
# end class thumbnailType


GDSClassesMapping = {
    'defaultAcl': acl,
    'thumbnail': thumbnailType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'stringPositionLocator'
        rootClass = stringPositionLocator
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'stringPositionLocator'
        rootClass = stringPositionLocator
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'stringPositionLocator'
        rootClass = stringPositionLocator
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:tns="http://www.palantirtech.com/pg/schema/import/"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'stringPositionLocator'
        rootClass = stringPositionLocator
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from pxml import *\n\n')
        sys.stdout.write('import pxml as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "acl",
    "aclReference",
    "aclSet",
    "aclSpecification",
    "dataSource",
    "dataSourceRecord",
    "dataSourceRecordSet",
    "dataSourceSet",
    "gisData",
    "graph",
    "link",
    "linkSet",
    "media",
    "mediaSet",
    "note",
    "noteSet",
    "object",
    "objectSet",
    "palantir",
    "point",
    "primaryObject",
    "property",
    "propertyComponent",
    "propertyRawValue",
    "propertySet",
    "propertyTimeInterval",
    "propertyUnparsedValue",
    "propertyValue",
    "stringPositionLocator",
    "thumbnailType",
    "timeInterval",
    "timestamp",
    "userElevation",
    "userLatLong",
    "userMGRS",
    "userUTM"
]
